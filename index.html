<!DOCTYPE html>
<html>
<head>
	<title>Kaiju Card</title>
	<style type="text/css">
		body {
			width: 960px;
			height: 540px;
			margin: 0;
			font-family: "Garamond";
		}

		body > div {
			overflow: hidden;
			background: linear-gradient(to right, #ddffdd, #ffdddd);
			height: 100%;
			display: none;
		}

		#mainScreen {
			display: block;
		}

		#mainTitle {
			text-align: center;
		}

		.bigWord {
			font-size: 6em;
			margin: 30px;
		}

		#mainButtons {
			text-align: center;
			width: 44%;
			margin: 50px auto;
		}

		#mainButtons button {
			margin: 25px;
		}

		#ruleTitle {
			text-align: center;
			height: 20%;
			padding: 10px;
			box-sizing: border-box;
		}

		#ruleText {
			height: 80%;
			overflow-y: scroll;
			padding-left: 25%;
			padding-right: 25%;
		}

		#deckScreen > div {
			box-sizing: border-box;
			border: 1px solid black;
		}

		#deckTitle {
			text-align: center;
			height: 20%;			
		}

		#deckTitle  button {
			margin: 15px;
		}

		#deckLibrary {
			height: 80%;
			width: 70%;
			overflow-y: scroll;
			float: left;
		}

		#deckList {
			height: 80%;
			width: 30%;
			overflow-y: scroll;
			padding-left: 20px;
		}

		.libraryItem {
			border-bottom: 1px solid black;
			height: 100px;
			width: 100%;
		}

		.libraryItem > div {
			float: left;			
		}

		.libraryNum {
			font-size: 4em;
			margin-left: 20px;
			margin-right: 20px;
			margin-top: 15px;
		}

		.card {
			height: 90px;
			width: 70px;
			margin: 4px;
			border: 1px solid black;
			overflow: hidden;
			text-align: left;
			white-space: normal;
		}

		.card p {
			margin: 2px;
		}

		.cardLocation { background-color: white; }

		.uncastable {
			background-color: black;
			color: white;
		}

		.cardText { font-size: 0.5em; }

		.add1, .add5, .remove1, .remove5, #cancelLg {
			margin-top: 40px;
			margin-left: 15px;
			margin-right: 15px;
		}

		.listItem {
			display: none;
		}

		#cardPopupDeck {
			display: none;
			position: absolute;
			text-align: center;
			top: 144px;
			left: 180px;
			width: 600px;
			height: 200px;
			background-color: white;
			padding: 20px;
		}

		#savePopup {
			display: none;
			position: absolute;
			top: 120px;
			left: 280px;
			width: 400px;
			height: 200px;
			background-color: white;
			text-align: center;
			padding: 40px;
		}

		#savePopup button {
			width: 60px;
			margin: 10px;
		}

		#savePopup input {
			margin: 10px;
		}

		#winScreen {
			text-align: center;
			background-image: none;
			background-color: #ddffdd;
		}

		#loseScreen {
			text-align: center;
			background-image: none;
			background-color: #ffdddd;
		}

		#gameScreen > div {
			/*border: 1px solid black;*/
			box-sizing: border-box;
			float: left;
		}

		#gameMessageBox {
			height: 75%;
			width: 20%;
			padding-left: 25px;
			padding-right: 25px;
			padding-top: 80px;
		}

		#redText {
			color: red;
			font-size: 1.8em;
			position: absolute;
			top: 7px;
			left: 27px;
		}

		#blackText { 
			font-size: 1.8em;
			position: absolute;
			top: 5px;
			left: 25px;
		}

		#phaseDetail { font-size: 1.2em; }

		#moneyNum {
			font-size: 2.2em;
			margin-top: 20px;
			margin-bottom: 20px;
		}

		#gameHPBox {
			height: 10%;
			width: 80%;
			padding-top: 15px;
			padding-left: 80px;
		}

		#outerHP {
			height: 12px;
			width: 600px;
			border: 1px solid black;
			margin-right: 20px;
			float: left;
		}

		#innerHP {
			height: 100%;
			width: 100%;
			background-color: #ee88bb;
		}

		#numHP { float: left; }

		#gameMechBox, #gameMonsterBox {
			width: 20%;
			height: 65%;
		}

		#gameTileBox {
			width: 40%;
			height: 65%;
			padding-left: 30px;
			padding-top: 2px;
		}

		#gameTileBox > div {
			height: 81px;
			width: 81px;
			box-sizing: border-box;
			border-top: 1px solid black;
			border-left: 1px solid black;
			float: left;
			font-size: 0.8em;
			padding-left: 10px;
		}

		.rightTile { border-right: 1px solid black; }

		.bottomTile {border-bottom: 1px solid black;}

		.tileImage {
			font-family: "Courier New";
			float: left;
			margin-right: 15px;
			padding-top: 5px;
		}

		.tileHP {
			font-size: 1.6em;
			color: purple;
			text-align: right;
			padding-right: 10px;
		}

		#gameCardBox {
			overflow-x: scroll;
			width: 90%;
			height: 25%;
			text-align: center;
			white-space: nowrap;
		}

		#gameCardBox > div {
			display: inline-block;
		}

		#gameScreen > button {
			margin-left: 10px;
			margin-top: 30px;
		}

		#tileZoom, #cardZoom {
			display: none;
			position: absolute;
			border: 1px solid black;
			background-color: white;
			text-align: center;
		}

		#cardZoom {
			top: 140px;
			left: 180px;
			width: 225px;
			height: 240px;
			padding: 15px;
		}

		#cardZoom > button { margin: 15px; }

		#tileZoom {
			top: 100px;
			left: 240px;
			width: 600px;
			height: 300px;
			padding: 25px;
			overflow-y: scroll;
		}

		#tileZoom > button { margin: 15px; }

		.projectileTemplate, .smallProjectileTemplate {
			display: none;
			position: absolute;
			background-color: green;
		}

		.projectileTemplate {
			width: 20px;
			height: 20px;
		}

		.smallProjectileTemplate {
			width: 10px;
			height: 10px;
		}
		
	</style>
</head>
<body>
	<div id="mainScreen">
		<div id="mainTitle">
			<em><h1 class="bigWord">Kaiju Card</h1></em>
			<p>by Tony Youssef</p>
		</div>
		<div id="mainButtons">
			
			<hr>
			<p>Current deck:   
			<select id="deckSelect">
				<option value = "(Basic) Burn">(Basic) Burn</option>
				<option value = "(Basic) Money">(Basic) Money</option>
				<option value = "(Basic) Turrets">(Basic) Turrets</option>
			</select></p>
			
			<hr>
			<p></p>
			<button onclick="newDeck()">New Deck</button>
			<button onclick="editDeck()">Edit Deck</button>
			<button onclick="rules()">Rules</button>
			<p></p>
			<button onclick="beginNormal()">New Game (Normal)</button>
			<button onclick="beginHard()">New Game (Hard)</button>
		</div>
	</div>

	<div id="ruleScreen">
		<div id="ruleTitle">
		<button onclick="rulesToMain()">Back to Main Menu</button>
		<h1>Rules</h1>
		</div>
		<div id="ruleText">
			<strong><p>Deck Editor</p></strong>
			<p>Click on a card to read its text.</p>
			<p>Your deck must have exactly 40 cards with at most 5 copies of each card.</p>
			<p>You can't delete or overwrite the three (Basic) decks.</p>
			<hr>
			<strong><p>Money</p></strong>
			<p>Your base income starts at 10 and goes up by 10 every turn. Banks generate an additional 10 income each, and some tiles can be improved to generate more income.</p>
			<p>Money that you don't spend isn't carried over between turns. At the start of each turn, it's set to your income.</p>
			<hr>
			<strong><p>Casting Phase</p></strong>
			<p>You start with 4 cards in hand and draw 2 new cards each turn.</p>
			<p>Click on a tile to see what its current stats and effects are. Click on a card to read its text and to get the option to cast it.</p>
			<p>Cards with "None" take effect immediately (unless they require you to discard cards). Other cards require you to select a target tile after casting. Cards with "Any" can target any non-destroyed tile. Cards with "Rubble" can only target destroyed tiles. If a card's location line is blacked out, that card can't be cast right now.</p>
			<p>Destroyed tiles lose all beneficial effects you have added to them. When rebuilt, they go back to their default stats (except for their hit points, and the effects of Eat and Safety cards).</p>
			<hr>
			<strong><p>Turrets and Monster Actions</p></strong>
			<p>Your turrets fire for 10 damage each at the end of each turn. Gun tiles start with 1 turret.</p>
			<p>After your turrets fire, the monster attacks. On the first turn, the monster will attack random tiles 3 times, dealing 1 damage with each attack.</p>
			<p>Tiles with high threat are 4x more likely to be attacked than other tiles. Tiles with low threat are 4x less likely to be attacked. The statue starts with high threat.</p>
			<p>When the monster rampages, it attacks 6 times. The monster also has rare attacks which ignore some attack modifiers.</p>
			<hr>
			<strong><p>Winning and Losing</p></strong>
			<p>When the monster is reduced to 0 hit points, you win!</p>
			<p>If all the city tiles are destroyed, the game is over.</p>
			<p>Playing on hard mode gives the monster 100 extra hit points to start with, and increases the chance of rampaging from 50% to 60%.</p>
		</div>
	</div>

	<div id="deckScreen">
		<div id="deckTitle">
		<div><span id="deckNameDeck"></span>  
			<button onclick="deckToMain()">Back to Main Menu (without saving)</button>
		</div>
		<button onclick="saveOverF()" id="saveOver">Save (overwrite)</button>
		<button onclick="saveNewF()" id="saveNew">Save as new deck</button>
		<button onclick="delDeckF()" id="delDeck">Delete deck</button>
		</div>
		<div id="deckLibrary">
			<div class="libraryItem">
				<div class="libraryNum">0</div>
				<div class="card">
					<strong><p class="cardName"></p></strong>
					<p class="cardCost"></p>
					<p class="cardLocation"></p>
					<p class="cardText"></p>
				</div>
				<div>
					<button class="add1">Add 1</button>
					<button class="add5">Add 5</button>
					<button class="remove1">Remove 1</button>
					<button class="remove5">Remove 5</button>
				</div>
			</div>
		</div>
		<div id="deckList">
			<strong><p>Total cards <span id="totalCards">0</span>/40</p></strong>
			<p class="listItem"><span class="listNum">0</span> <span class="listName"></span></p>
		</div>
		<div id="cardPopupDeck">
			<strong><p id="cardNameLg"></p></strong>
			<p id="cardTextLg"></p>
			<button class="add1">Add 1</button>
			<button class="add5">Add 5</button>
			<button class="remove1">Remove 1</button>
			<button class="remove5">Remove 5</button>
			<button id="cancelLg" onclick="cancelLg()">Close</button>
		</div>
		<div id="savePopup">
			<div id="saveTip"></div>
			<input type="text" id="saveName" onkeyup="saveEnter()">
			<div>
				<button onclick="saveOK()">OK</button>
				<button onclick="saveCancel()">Cancel</button>
			</div>
		</div>
	</div>

	<div id="winScreen">
		<h1 class="bigWord">You Win!</h1>
		<p>The city is safe.</p>
		<button onclick="winToMain()">Back to Main Menu</button>
	</div>

	<div id="loseScreen">
		<h1 class="bigWord">Game Over</h1>
		<p>The city is destroyed.</p>
		<button onclick="loseToMain()">Back to Main Menu</button>
	</div>

	<div id="gameScreen">
		<div id="gameMessageBox">
			<p id="redText"></p>
			<p id="blackText"></p>
			<hr>
			<p id="turnNum"></p>
			<p id="incomeNum"></p>
			<p id="energyNum"></p>
			<hr>
			<p id="moneyNum"></p>
			<hr>
			<p id="phaseDetail"></p>
			<button id="cancelTarget" onclick="cancelTargetF()">Cancel</button>
		</div>
		<div id="gameHPBox">
			<div id="outerHP"><div id="innerHP"></div></div><div id="numHP"></div>
		</div>
		<div id="gameMechBox">
			<canvas width="192" height ="351"></canvas>
		</div>
		<div id="gameTileBox">
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div class="bottomTile"></div><div class="bottomTile"></div><div class="bottomTile"></div><div class="bottomTile rightTile"></div>
		</div>
		<div id="gameMonsterBox">
			<canvas width="192" height ="351"></canvas>
		</div>
		<div id="gameCardBox">

		</div>
		<button onclick="endTurn()">End Turn</button>
		<div id="tileZoom">
			<strong><p id="zoomTileName"></p></strong>
			<p id="zoomTileDetails"></p>
			<p id="zoomTileEffects"></p>
			<button onclick="cancelTileZoom()">Close</button>
		</div>
		<div id="cardZoom">
			<strong><p id="zoomCardName"></p></strong>
			<p id="zoomCardText"></p>
			<button id="castClick" onclick="castClickF()">Cast</button>
			<button onclick="cancelCardZoom()">Close</button>
		</div>
		<div class="projectileTemplate"></div>
		<div class="smallProjectileTemplate"></div>
	</div>

<script type="text/javascript">
	mainScreen = document.getElementById("mainScreen");
	ruleScreen = document.getElementById("ruleScreen");
	gameScreen = document.getElementById("gameScreen");
	deckNameDeck = document.getElementById("deckNameDeck");
	deckSelect = document.getElementById("deckSelect");
	saveOver = document.getElementById("saveOver");
	saveNew = document.getElementById("saveNew");
	delDeck = document.getElementById("delDeck");
	savePopup = document.getElementById("savePopup");
	saveTip = document.getElementById("saveTip");
	saveName = document.getElementById("saveName");
	libraryItem = document.querySelector(".libraryItem");
	deckLibrary = document.getElementById("deckLibrary");
	listItem = document.querySelector(".listItem");
	deckList = document.getElementById("deckList");
	totalCards = document.getElementById("totalCards");
	cardPopupDeck = document.getElementById("cardPopupDeck");
	cardTextLg = document.getElementById("cardTextLg");
	cardNameLg = document.getElementById("cardNameLg");
	gameCardBox = document.getElementById("gameCardBox");
	numHP = document.getElementById("numHP");
	innerHP = document.getElementById("innerHP");
	turnNum = document.getElementById("turnNum");
	incomeNum = document.getElementById("incomeNum");
	energyNum = document.getElementById("energyNum");
	moneyNum = document.getElementById("moneyNum");
	phaseDetail = document.getElementById("phaseDetail");
	cancelTarget = document.getElementById("cancelTarget");
	tileZoom = document.getElementById("tileZoom");
	zoomTileName = document.getElementById("zoomTileName");
	zoomTileDetails = document.getElementById("zoomTileDetails");
	zoomTileEffects = document.getElementById("zoomTileEffects");
	cardZoom = document.getElementById("cardZoom");
	zoomCardName = document.getElementById("zoomCardName");
	zoomCardText = document.getElementById("zoomCardText");
	castClick = document.getElementById("castClick");
	projectileTemplate = document.querySelector(".projectileTemplate");
	smallProjectileTemplate = document.querySelector(".smallProjectileTemplate");

	var cardDictionary = {
		Ancestors: {
			cost: 40,
			location: "None",
			text: "Draw 3 cards",
			cast: function() { drawCard(); drawCard(); drawCard(); }
		},
		Battery: {
			cost: 40,
			location: "Any",
			text: "Mech gets +1 energy",
			cast: function() {				
				addEnergy(1);
				currentTile.effects.push({
					desc: function() { return "Mech gets +1 energy"; },
					func: function() { addEnergy(-1); },
					duration: -1
				});
			}
		},
		Bells: {
			cost: 10,
			location: "Church",
			text: "Church gets high threat for 1 turn. Draw a card",
			cast: function() {
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(4);
				currentTile.effects.push({
					desc: function() { return "High threat"; },
					func: null,
					duration: 1
				});
				drawCard();
			}
		},
		"Black Hole": {
			cost: 90,
			location: "None",
			text: "The monster loses 25% of its current hp",
			cast: function() { shoot(Math.ceil(monsterHP * 0.25)); }
		},
		Build: {
			cost: 50,
			location: "Any",
			text: "Tile gets +1 hp",
			cast: function() { currentTile.addHP(1); }
		},
		"Build+": {
			cost: 100,
			location: "Any",
			text: "Tile gets +2 hp",
			cast: function() { currentTile.addHP(2); }
		},
		Burn: {
			cost: 20,
			location: "None",
			text: "Deal 40 damage",
			cast: function() { shoot(40); }
		},
		"Burn+": {
			cost: 50,
			location: "None",
			text: "Deal 70 damage",
			cast: function() { shoot(70); }
		},
		Concuss: {
			cost: 40,
			location: "None",
			text: "Deal 10 damage. Monster attacks 1 less time next turn, up to 3 times per turn",
			restricted: function() { return (reducedAttacks == 3); },
			cast: function() { shoot(10); reducedAttacks += 1; }
		},
		"Cow Launcher": {
			cost: 40,
			location: "Farm",
			text: "Add 2 turrets to your farm for 3 turns",
			cast: function() {
				var n = currentTile;
				n.guns += 2;
				currentTile.effects.push({
					desc: function() { return "2 temporary turrets"; },
					func: function() { n.guns -= 2; },
					duration: 3
				});
			}
		},
		Distract: {
			cost: 10,
			location: "None",
			text: "Monster heals 40hp. Monster attacks 1 less time next turn, up to 3 times per turn",
			restricted: function() { return (reducedAttacks == 3 || monsterMaxHP - monsterHP < 40); },
			cast: function() { addMonsterHP(40); reducedAttacks += 1; }
		},
		"Divine Favor": {
			cost: 70,
			location: "Church",
			text: "Draw an extra card each turn",
			cast: function() {
				cardsPerTurn += 1;
				currentTile.effects.push({
					desc: function() { return "Draw an extra card each turn"; },
					func: function() { cardsPerTurn -= 1; },
					duration: -1
				});
			}
		},
		"Divine Protection": {
			cost: 100,
			location: "Church",
			text: "-1 attack on rampage. Stacks thrice",
			restricted: function() { return (reducedRampage == 3); },
			cast: function() {
				reducedRampage += 1;
				currentTile.effects.push({
					desc: function() { return "-1 attack on rampage"; },
					func: function() { reducedRampage -= 1; },
					duration: -1
				});
			}
		},
		Eat: {
			cost: 0,
			location: "Farm",
			text: "Reduce farm's monster healing by 40. Stacks thrice",
			restricted: function() { return (farmNum == 0); },
			cast: function() { farmNum -= 40; }
		},
		Explosion: {
			cost: 70,
			location: "Any",
			text: "Deal 1 damage to your own tile and 150 damage to the monster",
			cast: function() { currentTile.addHP(-1); addMonsterHP(-150); }
		},
		Gamble: {
			cost: 20,
			location: "None",
			text: "You have a 50% chance to gain $40 this turn",
			cast: function() {
				if (Math.random() < 0.5) {
					blackText.textContent = "Yay! :)";
					addMoney(40);
				} else blackText.textContent = "No! :(";
			}
		},
		"Golden Gun": {
			cost: 40,
			location: "Bank",
			text: "Deal 40 damage. This bank gains high threat for 2 turns",
			cast: function() {
				shoot(40);
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(4);
				currentTile.threat.push(4);
				currentTile.effects.push({
					desc: function() { return "High threat"; },
					func: null,
					duration: 2
				});
			}
		},
		Grant: {
			cost: 0,
			location: "None",
			text: "Gain $10 this turn",
			cast: function() { addMoney(10); }
		},
		"Hidden Turret": {
			cost: 50,
			location: "Any",
			text: "Tile gets low threat for 1 turn. Tile gets a turret",
			cast: function() {
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(0.25);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 1
				});
				currentTile.guns += 1;
			}
		},
		Income: {
			cost: 30,
			location: "Bank",
			text: "Bank generates +$10/turn",
			cast: function() { currentTile.income += 10; addIncome(10); }
		},
		"Income+": {
			cost: 60,
			location: "Bank",
			text: "Bank generates +$20/turn",
			cast: function() { currentTile.income += 20; addIncome(20); }
		},
		Laser: {
			cost: 60,
			location: "None",
			text: "Deal 40 damage for each energy you have",
			cast: function() { shoot(energy * 40); }
		},
		"Laser+": {
			cost: 120,
			location: "None",
			text: "Deal 70 damage for each energy you have",
			cast: function() { shoot(energy * 70); }
		},
		Loan: {
			cost: 0,
			location: "None",
			discard: 2,
			text: "Discard 2 cards. Gain $20 this turn",
			cast: function() { addMoney(20); }
		},
		Market: {
			cost: 90,
			location: "Farm",
			text: "Farm generates +$30 per turn",
			cast: function() { currentTile.income += 30; addIncome(30); }
		},
		Melt: {
			cost: 20,
			location: "None",
			text: "Spend all your remaining money this turn. Deal that much damage",
			restricted: function() { return (money == 20); },
			cast: function() { shoot(money); addMoney(-money); }
		},
		Missile: {
			cost: 30,
			location: "None",
			text: "Deal 30 damage and draw a card",
			cast: function() { shoot(30); drawCard(); }
		},
		"Missile+": {
			cost: 60,
			location: "None",
			text: "Deal 40 damage and draw 2 cards",
			cast: function() { shoot(40); drawCard(); drawCard(); }
		},
		"Missile++": {
			cost: 80,
			location: "None",
			text: "Deal 60 damage and draw 3 cards",
			cast: function() { shoot(60); drawCard(); drawCard(); drawCard(); }
		},
		"Multi Turret": {
			cost: 90,
			location: "None",
			text: "3 times, add a turret to a random tile",
			cast: function() {
				for (var j = 0; j < 3; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].guns += 1;
						tiles[x].flash();
					}
				}
			}
		},
		"Multi Turret+": {
			cost: 100,
			location: "None",
			text: "4 times, add a turret to a random tile",
			cast: function() {
				for (var j = 0; j < 3; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].guns += 1;
						tiles[x].flash();
					}
				}
			}
		},
		Power: {
			cost: 80,
			location: "Plant",
			text: "Mech gets +2 energy",
			cast: function() {				
				addEnergy(2);
				currentTile.effects.push({
					desc: function() { return "Mech gets +2 energy"; },
					func: function() { addEnergy(-2); },
					duration: -1
				});
			}
		},
		Rebuild: {
			cost: 100,
			location: "Rubble",
			text: "Rebuild a destroyed tile. It gets 2hp",
			cast: function() { resetTile(currentTile); currentTile.addHP(2 - currentTile.hp); }
		},
		Reinforce: {
			cost: 80,
			location: "None",
			text: "2 times, a random tile gets +1hp",
			cast: function() {
				for (var j = 0; j < 2; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		},
		"Reinforce +": {
			cost: 110,
			location: "None",
			text: "3 times, a random tile gets +1hp",
			cast: function() {
				for (var j = 0; j < 3; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		},
		Rig: {
			cost: 10,
			location: "Any",
			text: "If this tile is destroyed in the next 2 turns, it deals 50 damage to the monster",
			cast: function() {
				var n = currentTile;
				n.explo += 50;
				n.effects.push({
					desc: function() { return "When destroyed, deal 50 damage"; },
					func: function() { n.explo -= 50; },
					duration: 2
				});
			}
		},
		Safety: {
			cost: 50,
			location: "Plant",
			text: "Reduce plant's explosion damage by 3. Stacks twice",
			restricted: function() { return (plantNum == 0); },
			cast: function() { plantNum -= 3; }
		},
		Savings: {
			cost: 20,
			location: "None",
			text: "Any unspent money this turn carries over to next turn",
			restricted: function() { return saveMoney; },
			cast: function() { saveMoney = true; }
		},
		"Secret Project": {
			cost: 120,
			location: "Rubble",
			text: "Rebuild a destroyed tile. It gets 2hp. It gains low threat for 3 turns",
			cast: function() {
				resetTile(currentTile);
				currentTile.addHP(2 - currentTile.hp);
				currentTile.threat.push(0.25);
				currentTile.threat.push(0.25);
				currentTile.threat.push(0.25);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 3
				});
			}
		},
		Shiny: {
			cost: 20,
			location: "Any",
			text: "Tile gets high threat",
			cast: function() { currentTile.threat = [4]; }
		},
		Sift: {
			cost: 0,
			location: "None",
			discard: 2,
			text: "Discard 2 cards, then draw 2 cards",
			cast: function() { drawCard(); drawCard(); }
		},
		Stealth: {
			cost: 30,
			location: "Any",
			text: "Tile gets low threat for 3 turns",
			cast: function() {
				for (var j = 0; j < 3; j++)
					if (currentTile.threat.length > 1)
						currentTile.threat.splice(-1);
				for (var j = 0; j < 3; j++)
					currentTile.threat.push(0.25);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 3
				});
			}			
		},
		Surge: {
			cost: 100,
			location: "Plant",
			text: "Deal 1 damage to your plant and 200 damage to the monster",
			cast: function() { currentTile.addHP(-1); addMonsterHP(-200); }
		},
		Sword: {
			cost: 0,
			location: "None",
			text: "Deal 20 damage",
			cast: function() { shoot(20); }
		},
		"Time Travel": {
			cost: 160,
			location: "None",
			text: "Take an extra turn after this one",
			cast: function() { extraTurns += 1; }
		},
		"Tough Turret": {
			cost: 80,
			location: "Any",
			text: "Tile gets +1hp and a turret",
			cast: function() { currentTile.addHP(1); currentTile.guns += 1; }
		},
		Treasure: {
			cost: 30,
			location: "Bank",
			text: "When this bank is destroyed, gain $30 at the start of your next turn",
			cast: function() {
				currentTile.effects.push({
					desc: function() { return "When destroyed, gain $30 at the start of your next turn"; },
					func: function() { extraMoney += 30; },
					duration: -1
				});
			}
		},
		Turret: {
			cost: 30,
			location: "Any",
			text: "Tile gets another turret",
			cast: function() { currentTile.guns += 1; }
		},
		"Turret+": {
			cost: 70,
			location: "Any",
			text: "Tile gets 2 more turrets",
			cast: function() { currentTile.guns += 2; }
		},
		Volley: {
			cost: 50,
			location: "None",
			text: "Your turrets fire a volley",
			restricted: noTurrets,
			cast: volley
		},
		"Volley+": {
			cost: 100,
			location: "None",
			text: "Your turrets fire two volleys",
			restricted: noTurrets,
			cast: function() { volley(); qVolley = true; }
		},
		Weld: {
			cost: 100,
			location: "None",
			text: "For each energy you have, a random tile gets +1 hp",
			cast: function() {
				for (var j = 0; j < energy; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		}
	};

	var colorType = {
		Any: "#dddddd",
		Bank: "#ffffaa",
		None: "#ffaaff",
		Church: "#bbbbff",
		Plant: "#cc99ff",
		Farm: "#aaffaa",
		Rubble: "#bbbbbb"
	};

	var basicDecks = {
		"(Basic) Burn": "5Burn5Burn+5Concuss5Eat5Explosion5Missile5Missile+5Sword",
		"(Basic) Money": "5Black Hole5Grant5Income5Income+5Loan5Market5Melt5Reinforce +",
		"(Basic) Turrets": "5Cow Launcher5Distract5Grant5Tough Turret5Turret5Turret+5Volley5Volley+"
	};

	var tileOrder = [
		"Wall", "Guns", "Bank", "Wall",
		"Bank", "Church", "Statue", "Guns",
		"Guns", "Plant", "Farm", "Bank",
		"Wall", "Bank", "Guns", "Wall"
	];

	var tileDictionary = {
		"Wall": {
			hp: 3,
			guns: 0,
			income: 0,
			image: "##<br>##<br>##"
		},
		"Guns": {
			hp: 2,
			guns: 1,
			income: 0,
			image: "&nbsp;/<br>/o<br>##"
		},
		"Bank": {
			hp: 3,
			guns: 0,
			income: 10,
			image: "$$<br>__<br>##"
		},
		"Farm": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "__<br>__<br>__"
		},
		"Plant": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "||<br>/\\<br>##"
		},
		"Statue": {
			hp: 2,
			guns: 0,
			income: 0,
			image: "\\o<br>||<br>/\\"
		},
		"Church": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "/\\<br>||<br>/\\"
		}
	};

	var overlay = false;
	var i;
	var library = {};
	var total = 0;
	var deck, origDeck;
	var monsterHP, monsterMaxHP, rampageChance;
	var tiles = [];
	var gameMode;
	var currentCard, currentTile, nome;
	var income, money, turn, cardsPerTurn, energy;
	var saveMoney;
	var extraTurns, extraMoney;
	var plantNum, farmNum;
	var reducedAttacks, reducedRampage;
	var setAttacks, toHit;
	var qWin, qLose, qPlant, qVolley, qAttack, qBetween;
	var projectiles = 0;
	
	drawMech();
	drawMonster();

	for (i=0; i < localStorage.length; i++) addToList(localStorage.key(i));
	for (var el in cardDictionary) {
		node = libraryItem.cloneNode(true);
		node.querySelector(".cardName").textContent = el;
		node.querySelector(".cardCost").textContent = "$" + cardDictionary[el].cost;
		node.querySelector(".cardLocation").textContent = cardDictionary[el].location;
		node.querySelector(".cardText").textContent = cardDictionary[el].text;
		node.querySelector(".card").style["background-color"] = colorType[cardDictionary[el].location];

		node2 = listItem.cloneNode(true);
		node2.querySelector(".listName").textContent = el;

		library[el] = {
			quantity: 0,
			node: node,
			node2: node2,
			addCards: addCards
		};
		
		createAddListener(node.querySelector(".add1"), library[el], 1, true);
		createAddListener(node.querySelector(".add5"), library[el], 5, true);
		createAddListener(node.querySelector(".remove1"), library[el], -1, true);
		createAddListener(node.querySelector(".remove5"), library[el], -5, true);
		createCardListener(node.querySelector(".card"), el);
		deckLibrary.appendChild(node);
		deckList.appendChild(node2);
	}
	libraryItem.style.display = "none";

	var tileDivs = document.querySelectorAll("#gameTileBox > div");
	for (i = 0; i < 16; i++) {
		node = tileDivs[i];
		tileName = tileOrder[i];
		tiles.push({
			node: node,
			nome: tileName,
			hp: 0,
			income: 0,
			guns: 0,
			explo: 0,
			addHP: function(amount) {
				if (this.hp == 0) return;
				this.hp += amount;
				this.node.querySelector(".tileHP").textContent = this.hp;
				if (this.hp == 0) {
					if (this.timer) clearTimeout(this.timer);
					this.node.style["background-color"] = "#bbbbbb";
					gameTileBox.style["padding-left"] = "34px";
					setTimeout(function() { gameTileBox.style["padding-left"] = "30px"; }, 130);
					addIncome(-this.income);
					if (playerLost()) {
						if (gameMode == "animating") qLose = true; else gameOver();
					}
					for (var j = 0; j < this.effects.length; j++) {
						if (this.effects[j].duration == -1) this.effects[j].func();
					}
					addMonsterHP(-this.explo);
				}
			},
			flash: function() {
				var n = this.node;
				n.style["background-color"] = "yellow";
				this.timer = setTimeout(function() { n.style["background-color"] = ""; this.timer = null; }, 130);
			},
			lastThreat: function() { return this.threat[this.threat.length - 1]; }
		});
		newP = document.createElement("p");
		newP.innerHTML = tileDictionary[tileName].image;
		newP.classList.add("tileImage");
		node.appendChild(newP);
		newP = document.createElement("p");
		newP.textContent = tileName;
		node.appendChild(newP);
		newP = document.createElement("p");
		newP.classList.add("tileHP");
		node.appendChild(newP);
		createTileListener(tiles[i]);
	}

	function resetTile(tile) {
		tile.hp = tileDictionary[tile.nome].hp;
		tile.income = tileDictionary[tile.nome].income;
		addIncome(tileDictionary[tile.nome].income);
		tile.guns = tileDictionary[tile.nome].guns;
		tile.explo = 0;
		tile.node.style["background-color"] = "";
		tile.node.querySelector(".tileHP").textContent = tile.hp;
		if (tile.nome == "Statue")
			tile.threat = [4];
		else
			tile.threat = [1];
		tile.effects = [];
		if (tile.nome == "Plant") tile.effects.push({
			desc: function() { return "When destroyed, damage random tiles " + plantNum + " times"; },
			func: function() {
				if (gameMode == "animating") qPlant = true; else plantExplosion();
			},
			duration: -1
		});
		if (tile.nome == "Farm") tile.effects.push({
			desc: function() { return "When destroyed, the monster heals " + farmNum + " hp"; },
			func: function() { addMonsterHP(farmNum); },
			duration: -1
		});
	}

	function createTileListener(tile) {
		tile.node.onclick = function() {
			if (gameMode == "targetting" && legalTarget(tile, nome)) {
				currentTile = tile;
				tile.flash();
				cast();
			} else if (gameMode == "casting") {
				setMode("zooming");
				nameStr = tile.nome;
				if (tile.lastThreat() == 4) nameStr += " - high threat";
				if (tile.lastThreat() == 0.25) nameStr += " - low threat";
				nameStr += " - " + tile.hp + " hit points";
				zoomTileName.textContent = nameStr;
				zoomTileDetails.textContent = "Turrets: " + tile.guns + " --- Income: $" + tile.income + " per turn";
				fxStr = "";			
				for (var j = 0; j < tile.effects.length; j++) {
					if (j > 0) fxStr += "; ";
					fxStr += tile.effects[j].desc();
					if (tile.effects[j].duration > -1)
						fxStr += " (" + tile.effects[j].duration + " turns)";
				}
				if (fxStr == "")
					zoomTileEffects.textContent = "";
				else
					zoomTileEffects.textContent = "Effects: " + fxStr;
				tileZoom.style.display = "block";
			}
		}
	}

	function legalTarget(tile, cardName) {
		if (tile.hp == 0) return (cardDictionary[cardName].location == "Rubble");
		if (cardDictionary[cardName].location == "Any") return true;
		return (cardDictionary[cardName].location == tile.nome);
	}

	function createAddListener(button, obj, quantity, preventOnOverlay) {
		button.onclick = function(){
			if (overlay && preventOnOverlay) return;
			obj.addCards(quantity);
		};
	}

	function createCardListener(card, el) {
		card.onclick = function(){
			if(overlay) return;
			cardPopupDeck.style.display = "block";
			overlay = true;
			cardNameLg.textContent = el + " - $" + cardDictionary[el].cost + " - " + cardDictionary[el].location;
			cardTextLg.textContent = cardDictionary[el].text;
			createAddListener(cardPopupDeck.querySelector(".add1"), library[el], 1, false);
			createAddListener(cardPopupDeck.querySelector(".add5"), library[el], 5, false);
			createAddListener(cardPopupDeck.querySelector(".remove1"), library[el], -1, false);
			createAddListener(cardPopupDeck.querySelector(".remove5"), library[el], -5, false);
		};
	}

	function addCards(quantity) {
		newQ = this.quantity + quantity;
		if (newQ > 5) newQ = 5;
		if (newQ < 0) newQ = 0;
		addTotal(newQ - this.quantity);
		this.quantity = newQ;
		if (this.quantity == 0) this.node2.style.display = "none";
		else this.node2.style.display = "block";
		this.node2.querySelector(".listNum").textContent = this.quantity;
		this.node.querySelector(".libraryNum").textContent = this.quantity;
	}

	function addTotal(n) {
		total += n;
		totalCards.textContent = total;
		if (total < 40) totalCards.style.color = "red";
		if (total > 40) totalCards.style.color = "purple";
		if (total == 40) {
			totalCards.style.color = "green";
			saveNew.disabled = false;
			if (!delDeck.disabled) saveOver.disabled = false;
		} else {
			saveNew.disabled = true;
			saveOver.disabled = true;
		}
	}

	function cancelLg() {
		cardPopupDeck.style.display = "none";
		overlay = false;
	}

	function rules() {
		mainScreen.style.display = "none";
		ruleScreen.style.display = "block";
	}

	function newDeck() {
		deckNameDeck.textContent = "Untitled deck";
		saveOver.disabled = true;
		delDeck.disabled = true;
		resetLibrary();
		mainScreen.style.display = "none";
		deckScreen.style.display = "block";
	}

	function editDeck() {
		deckNameDeck.textContent = deckSelect.value;
		resetLibrary();
		if (basicName(deckSelect.value)) {
			saveOver.disabled = true;
			delDeck.disabled = true;
			loadDeck(basicDecks[deckSelect.value], false);
		} else {
			delDeck.disabled = false;
			loadDeck(localStorage.getItem(deckSelect.value), false);
		}
		mainScreen.style.display = "none";
		deckScreen.style.display = "block";
	}

	function resetLibrary() {
		for (el in library) {
			library[el].addCards(-5);
		}
	}

	function saveDeck() {
		var str = "";
		for (el in library)
			if (library[el].quantity > 0) str += library[el].quantity + el;
		return str;
	}

	function loadDeck(str, loadToDeck) {
		var substr = "";
		var c;
		var x = str.charAt(0);
		for (i = 1; i < str.length; i++) {
			c = str.charAt(i);
			if (c >= '0' && c <= '9') {
				if (loadToDeck) {
					for (var j = 0; j < Number(x); j++)
						deck.push(substr);
				} else
					library[substr].addCards(Number(x));
				x = c;
				substr = "";
			} else substr += c;
		}
		if (loadToDeck) {
			for (var j = 0; j < Number(x); j++)
				deck.push(substr);
		} else
			library[substr].addCards(Number(x));
	}

	function beginNormal() {
		monsterMaxHP = 1450;
		rampageChance = 0.5;
		newGame();
	}

	function beginHard() {
		monsterMaxHP = 1550;
		rampageChance = 0.6;
		newGame();
	}

	function newGame() {
		deck = [];
		if (basicName(deckSelect.value)) {
			loadDeck(basicDecks[deckSelect.value], true);
		} else {
			loadDeck(localStorage.getItem(deckSelect.value), true);
		}
		origDeck = deck.slice(0);
		shuffle();
		while (gameCardBox.firstChild)
    		gameCardBox.removeChild(gameCardBox.firstChild);
		drawCard();
		drawCard();
		plantNum = 6;
		farmNum = 120;
		reducedRampage = 0;
		extraTurns = 0;
		toHit = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		qWin = false;
		qLose = false;
		qPlant = false;
		qVolley = false;
		qAttack = false;
		qBetween = false;
		monsterHP = 0;
		addMonsterHP(monsterMaxHP);
		energy = 0;
		addEnergy(1);
		income = 0;
		turn = 0;
		cardsPerTurn = 2;
		saveMoney = false;
		extraMoney = 0;
		for (i = 0; i < tiles.length; i++) resetTile(tiles[i]);
		setMode("casting");
		newTurn();
		
		mainScreen.style.display = "none";
		gameScreen.style.display = "block";
	}

	function shuffle() {
		var temp, rnd;
		for (i = 0; i < deck.length; i++) {
			rnd = Math.floor(Math.random() * (deck.length - i)) + i;
			temp = deck[i];
			deck[i] = deck[rnd];
			deck[rnd] = temp;
		}
	}

	function newTurn() {
		for (i = 0; i < cardsPerTurn; i++) drawCard();
		if (!saveMoney) money = 0;
		saveMoney = false;
		reducedAttacks = 0;
		addIncome(10);
		addMoney(income + extraMoney);
		extraMoney = 0;
		turn += 1;
		turnNum.textContent = "Turn " + turn;
		if (gameMode != "animating") setMode("casting");
	}

	function drawCard() {
		if (deck.length == 0) {
			deck = origDeck.slice(0);
			shuffle();
		}
		cardName = deck.pop();
		node = library[cardName].node.querySelector(".card").cloneNode(true);
		gameCardBox.appendChild(node);
		createCardInHandListener(node, cardName);
		gameCardBox.scrollLeft = gameCardBox.scrollWidth;
	}

	function castableAll() {
		var cardDivs = document.querySelectorAll("#gameCardBox > div");
		for (var j = 0; j < cardDivs.length; j++) {
			castable(cardDivs[j]);
		}
	}

	function castable(node) {
		var cardName = node.querySelector(".cardName").textContent;
		var stripe = node.querySelector(".cardLocation");
		if (cardDictionary[cardName].cost > money) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].discard && cardDictionary[cardName].discard > gameCardBox.childElementCount - 1) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].restricted && cardDictionary[cardName].restricted()) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].location == "None") {
			stripe.classList.remove("uncastable");
			return true;
		}
		for (var j = 0; j < 16; j++) {
			if (legalTarget(tiles[j], cardName)) {
				stripe.classList.remove("uncastable");
				return true;
			}
		}
		stripe.classList.add("uncastable");
		return false;
	}

	function createCardInHandListener(node, cardName) {
		node.onclick = function() {
			if (gameMode == "casting") {
				blackText.textContent = "";
				redText.textContent = "";
				currentCard = this;
				nome = cardName;
				setMode("zooming");
				zoomCardName.textContent = nome + " - $" + cardDictionary[nome].cost + " - " + cardDictionary[nome].location;
				zoomCardText.textContent = cardDictionary[nome].text;
				castClick.disabled = !castable(this);
				cardZoom.style.display = "block";
				castClick.focus();
			} else if (gameMode == "discarding" && this != currentCard) {
				setMode("discarding1");
				gameCardBox.removeChild(this);
			} else if (gameMode == "discarding1" && this != currentCard) {
				gameCardBox.removeChild(this);
				cast();
			}
		};
	}

	function cancelCardZoom() {
		cardZoom.style.display = "none";
		setMode("casting");
	}

	function castClickF() {
		cardZoom.style.display = "none";
		if (cardDictionary[nome].location == "None") {
			if (cardDictionary[nome].discard)
				setMode("discarding");
			else
				cast();
		} else {
			setMode("targetting");
		}		
	}

	function cast() {
		addMoney(-cardDictionary[nome].cost);
		cardDictionary[nome].cast();
		gameCardBox.removeChild(currentCard);
		castableAll();
		if (gameMode != "animating") setMode("casting");
	}

	function addMoney(amount) {
		money += amount;
		moneyNum.textContent = "$" + money;
	}

	function addIncome(amount) {
		income += amount;
		incomeNum.textContent = "Income: $" + income;
	}

	function addEnergy(amount) {
		energy += amount;
		energyNum.textContent = "Energy: " + energy;
	}

	function addMonsterHP(amount) {
		monsterHP += amount;
		if (monsterHP > monsterMaxHP) monsterHP = monsterMaxHP;
		if (monsterHP < 0) monsterHP = 0;
		numHP.textContent = monsterHP + "hp";
		innerHP.style.width = (100 * monsterHP / monsterMaxHP) + "%";
		if (amount < 0) {
			gameMonsterBox.style["padding-left"] = "4px";
			setTimeout(function() { gameMonsterBox.style["padding-left"] = ""; }, 130);
		}
		if (monsterHP == 0) {
			if (gameMode == "animating") qWin = true; else youWin();
		}
	}

	function shoot(amount) {
		setMode("animating");
		anim([{
			startX: 380,
			startY: 100,
			endX: 790,
			endY: 100,
			big: true,
			tile: null,
			damage: amount,
			shots: 1
		}], true);
	}

	function endTurn() {
		if (gameMode != "casting") return;
		volley();
		if (gameMode == "animating") qAttack = true; else attack();
		if (gameMode == "animating") qBetween = true; else betweenTurn();
	}

	function betweenTurn() {
		for (i = 0; i < 16; i++) {
			if (tiles[i].hp > 0) {
				if (tiles[i].threat.length > 1) tiles[i].threat.pop();
				for (var j = tiles[i].effects.length - 1; j >= 0; j--) {
					if (tiles[i].effects[j].duration > 1) {
						tiles[i].effects[j].duration -= 1;					
					} else if (tiles[i].effects[j].duration == 1) {
						if (tiles[i].effects[j].func) tiles[i].effects[j].func();
						tiles[i].effects.splice(j, 1);
					}
				}
			}

		}
		newTurn();
	}

	function volley() {
		if (noTurrets()) return;
		var array = [];
		setMode("animating");
		for (i = 0; i < 16; i++) {
			if (tiles[i].hp > 0 && tiles[i].guns > 0) {
				array.push({
					startX: 450 + 81 * (i % 4),
					startY: 70 + 81 * Math.floor(i / 4),
					endX: 800,
					endY: 100,
					big: false,
					tile: null,
					damage: 10,
					shots: tiles[i].guns
				});
			}
		}
		anim(array, false);
	}

	function noTurrets() {
		for (i = 0; i < 16; i++) {
			if (tiles[i].hp > 0 && tiles[i].guns > 0) return false;
		}
		return true;
	}

	function attack() {
		if (extraTurns > 0) {
			blackText.textContent = "Extra turn";
			extraTurns -= 1;
			return;
		}

		var rnd = turn == 1 ? 0.75 : Math.random();
		setAttacks = [];
		if (rnd >= 0.96) {
			blackText.textContent = "X attack!";
			redText.textContent = "X attack!";
			var rnd2;
			while (true) {
				rnd2 = 4 * Math.floor(Math.random() * 4);
				if (tiles[rnd2].hp > 0 || tiles[rnd2 + 1].hp > 0 || tiles[rnd2 + 2].hp > 0 || tiles[rnd2 + 3].hp > 0) break;
			}
			for (i = 0; i < 4; i++) {
				setAttacks.push(rnd2 + i);
			}
		} else if (rnd >= 0.92) {
			blackText.textContent = "Y attack!";
			redText.textContent = "Y attack!";
			var rnd2;
			while (true) {
				rnd2 = Math.floor(Math.random() * 4);
				if (tiles[rnd2].hp > 0 || tiles[rnd2 + 4].hp > 0 || tiles[rnd2 + 8].hp > 0 || tiles[rnd2 + 12].hp > 0) break;
			}
			for (i = rnd2; i < 16; i += 4) {
				setAttacks.push(i);
			}
		} else if (rnd >= 0.9) {
			blackText.textContent = "Z attack!";
			redText.textContent = "Z attack!";
			setAttacksByThreat(1);
			var x = setAttacks[0];
			setAttacks = [x, x, x, x];
		} else {
			var totalAttacks = 3 - reducedAttacks;
			if (rnd < rampageChance) totalAttacks += 3 - rampageChance;
			if (totalAttacks == 0) {
				blackText.textContent = "No attacks";
				return;
			}
			if (rnd < rampageChance) {
				blackText.textContent = "RAMPAGE";
				redText.textContent = "RAMPAGE";
			} else {
				blackText.textContent = "";
				redText.textContent = "";
			}
			setAttacksByThreat(totalAttacks);
		}
		array = [];
		for (i = 0; i < setAttacks.length; i++) {
			var x = setAttacks[i];
			toHit[x] = 0;
			array.push({
				startX: 790,
				startY: 100,
				endX: 445 + 81 * (x % 4),
				endY: 90 + 81 * Math.floor(x / 4),
				big: true,
				tile: tiles[x],
				damage: null,
				shots: 1
			});
		}
		setMode("animating");
		if (rnd >= 0.92) anim(array, false); else anim(array, true);
	}

	function setAttacksByThreat(numAttacks) {
		var totalThreat = 0;
		for (i = 0; i < 16; i++)
			if (tiles[i].hp > 0) totalThreat += tiles[i].lastThreat();
		for (i = 0; i < numAttacks; i++) {
			if (playerLost()) break;
			var threatTally;
			var rnd;
			while (true) {
				threatTally = 0;
				rnd = Math.random() * totalThreat;
				for (var j = 0; j < 16; j++) {
					if (tiles[j].hp > 0) {
						threatTally += tiles[j].lastThreat();
						if (threatTally > rnd) {
							if (tiles[j].hp - toHit[j] > 0) {
								toHit[j] += 1;
								setAttacks.push(j);
								break;
							} else j = 16;
						}
					}
				}
				if (j < 16) break;
			}
		}
	}

	function playerLost() {
		for (var j = 0; j < 16; j++)
			if (tiles[j].hp - toHit[j] > 0) return false;
		return true;
	}

	function setMode(str) {
		gameMode = str;
		if (str == "targetting" || str == "discarding") {
			cancelTarget.disabled = false;
		} else {
			cancelTarget.disabled = true;
		}
		if (str == "casting") {
			phaseDetail.textContent = "Casting phase";
			castableAll();
		}
		if (str == "targetting") {
			currentCard.style.border = "1px dashed purple";
			phaseDetail.textContent = "Target: " + cardDictionary[nome].location;
		}
		if (str == "animating")
			phaseDetail.textContent = "Please wait...";
		if (str == "discarding") {
			currentCard.style.border = "1px dashed purple";
			phaseDetail.textContent = "Discard 2 cards";
		}
		if (str == "discarding1")
			phaseDetail.textContent = "Discard 1 card";
	}

	function cancelTargetF() {
		setMode("casting");
		currentCard.style.border = "1px solid black";
	}

	function cancelTileZoom() {
		tileZoom.style.display = "none";
		setMode("casting");
	}

	function plantExplosion() {
		if (plantNum == 0 || playerLost()) {
			checkQueues();
			return;
		}
		var array = [];
		for (var j = 0; j < plantNum; j++) {
			if (playerLost()) break;
			var x = Math.floor(Math.random() * 16);
			if (tiles[x].hp - toHit[j] <= 0)
				j--;
			else {
				array.push({
					startX: 445 + 81,
					startY: 90 + 81 * 2,
					endX: 445 + 81 * (x % 4),
					endY: 90 + 81 * Math.floor(x / 4),
					big: true,
					tile: tiles[x],
					damage: null,
					shots: 1
				});
				toHit[x] += 1;
			}
		}
		for (var j = 0; j < 16; j++) toHit[j] = 0;
		setMode("animating");
		anim(array, true);
	}

	function youWin() {
		setMode("animating");
		gameScreen.style.display = "none";
		winScreen.style.display = "block";
	}

	function gameOver() {
		setMode("animating");
		gameScreen.style.display = "none";
		loseScreen.style.display = "block";
	}

	function winToMain() {
		winScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function loseToMain() {
		loseScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function addToList(name) {
		var option = document.createElement("option");
		option.text = name;
		option.value = name;
		deckSelect.add(option);
	}

	function rulesToMain() {
		ruleScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function deckToMain() {
		if (overlay) return;
		deckScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function saveOverF() {
		localStorage.setItem(deckSelect.value, saveDeck());
		deckToMain();
	}

	function saveNewF() {
		if (overlay) return;
		overlay = true;
		saveTip.textContent = "Enter deck name"
		saveName.value = "";
		savePopup.style.display = "block";
		saveName.focus();
	}

	function saveCancel() {
		savePopup.style.display = "none";
		overlay = false;
	}

	function saveEnter() {
		if (event.key == "Enter") saveOK();
	}

	function saveOK() {
		if (saveName.value == "" || basicName(saveName.value) || localStorage.getItem(saveName.value)) {
			saveTip.textContent = "Invalid name. Enter deck name"
		} else {
			localStorage.setItem(saveName.value, saveDeck());
			addToList(saveName.value);
			savePopup.style.display = "none";
			overlay = false;
			deckSelect.options[deckSelect.length - 1].selected = true;
			deckToMain();
		}
	}

	function delDeckF() {
		localStorage.removeItem(deckSelect.value);
		for (i = 0; i < deckSelect.options.length; i++)
			if (deckSelect.options[i].selected) deckSelect.remove(i);
		deckToMain();
	}

	function basicName(name) {
		if (name == "(Basic) Burn" || name == "(Basic) Money" || name == "(Basic) Turrets") return true;
		return false;
	}

	function drawMech() {
		canvas = document.querySelector("#gameMechBox canvas");
		ctx = canvas.getContext('2d');
		ctx.strokeRect(20, 20, 150, 310);
	}

	function drawMonster() {
		canvas = document.querySelector("#gameMonsterBox canvas");
		ctx = canvas.getContext('2d');
		ctx.beginPath();
		ctx.moveTo(20, 330);
		ctx.lineTo(40, 20);
		ctx.lineTo(150, 20);
		ctx.lineTo(170, 330);
		ctx.closePath();
		ctx.stroke();
	}

	function anim(array, seq) {
		for (var j = 0; j < array.length; j++) {
			for (var k = 0; k < array[j].shots; k++) {
				var startX = array[j].startX;
				var startY = array[j].startY;
				var endX = array[j].endX;
				var endY = array[j].endY;
				var big = array[j].big;
				var tile = array[j].tile;
				var damage = array[j].damage;
				createTimeout(startX, startY, endX, endY, big, tile, damage, k, j, seq);
			}
		}
	}

	function createTimeout(startX, startY, endX, endY, big, tile, damage, k, j, seq) {
		setTimeout(function() { createInterval(startX, startY, endX, endY, big, tile, damage); }, seq ? (k + j) * 320 : k * 320);
	}

	function createInterval(startX, startY, endX, endY, big, tile, damage) {
		projectiles += 1;
		var progress = 0;
		var icon = big ? projectileTemplate.cloneNode(false) : smallProjectileTemplate.cloneNode(false);
		icon.style.display = "block";
		if (!damage) icon.style["background-color"] = "red";
		icon.style.top = startY + "px";
		icon.style.left = startX + "px";
		gameScreen.appendChild(icon);
		var mint = setInterval(function() {
			progress += 0.025;
			if (progress > 1) {
				gameScreen.removeChild(icon);
				projectiles -= 1;
				if (projectiles == 0) {
					setMode("casting");
				}
				if (damage) {
					addMonsterHP(-damage);
				} else {
					tile.addHP(-1);
				}
				castableAll();
				if (projectiles == 0 && gameMode == "casting") {
					checkQueues();
				}
				clearInterval(mint);
			} else {
				icon.style.top = (progress * endY + (1 - progress) * startY) + "px";
				icon.style.left = (progress * endX + (1 - progress) * startX) + "px";
			}
		}, 20);
	}

	function checkQueues() {
		if (qLose) {
			gameOver();
		} else if (qWin) {
			youWin();
		} else if (qVolley) {
			qVolley = false;
			volley();
		} else if (qPlant) {
			qPlant = false;
			plantExplosion();
		} else if (qAttack) {
			qAttack = false;
			attack();
		} else if (qBetween) {
			qBetween = false;
			betweenTurn();
		}
	}

</script>
</body>
</html>
