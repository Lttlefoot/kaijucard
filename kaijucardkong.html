<!DOCTYPE html>
<html>
<head>
	<title>Kaiju Card</title>
	<script src='https://cdn1.kongregate.com/javascripts/kongregate_api.js'></script>
	<style type="text/css">
		body {
			width: 960px;
			height: 540px;
			margin: 0;
			font-family: "Garamond";
		}

		body > div {
			overflow: hidden;
			background: linear-gradient(to right, #ddffdd, #ffdddd);
			height: 100%;
			display: none;
		}

		#mainScreen {
			display: block;
		}

		#mainTitle {
			text-align: center;
		}

		.bigWord {
			font-size: 6em;
			margin: 30px;
		}

		#mainButtons {
			text-align: center;
			width: 44%;
			margin: 50px auto;
		}

		#mainButtons button {
			margin: 25px;
		}

		#ruleTitle {
			text-align: center;
			height: 20%;
			padding: 10px;
			box-sizing: border-box;
		}

		#ruleText {
			height: 80%;
			overflow-y: scroll;
			padding-left: 25%;
			padding-right: 25%;
		}

		#deckScreen > div {
			box-sizing: border-box;
			border: 1px solid black;
		}

		#deckTitle {
			text-align: center;
			height: 20%;			
		}

		#deckTitle  button {
			margin: 15px;
		}

		#deckLibrary {
			height: 80%;
			width: 70%;
			overflow-y: scroll;
			float: left;
		}

		#deckList {
			height: 80%;
			width: 30%;
			overflow-y: scroll;
			padding-left: 20px;
		}

		.libraryItem {
			border-bottom: 1px solid black;
			height: 100px;
			width: 100%;
		}

		.libraryItem > div {
			float: left;			
		}

		.libraryNum {
			font-size: 4em;
			margin-left: 20px;
			margin-right: 20px;
			margin-top: 15px;
		}

		.card {
			height: 90px;
			width: 70px;
			margin: 4px;
			border: 1px solid black;
			overflow: hidden;
			text-align: left;
			white-space: normal;
		}

		.card p {
			margin: 2px;
		}

		.cardLocation { background-color: white; }

		.uncastable {
			background-color: black;
			color: white;
		}

		.cardText { font-size: 0.5em; }

		.add1, .add5, .remove1, .remove5, #cancelLg {
			margin-top: 40px;
			margin-left: 15px;
			margin-right: 15px;
		}

		.listItem {
			display: none;
		}

		#cardPopupDeck {
			display: none;
			position: absolute;
			text-align: center;
			top: 144px;
			left: 180px;
			width: 600px;
			height: 200px;
			background-color: white;
			padding: 20px;
		}

		#savePopup {
			display: none;
			position: absolute;
			top: 120px;
			left: 280px;
			width: 400px;
			height: 200px;
			background-color: white;
			text-align: center;
			padding: 40px;
		}

		#savePopup button {
			width: 60px;
			margin: 10px;
		}

		#savePopup input {
			margin: 10px;
		}

		#winScreen {
			text-align: center;
			background-image: none;
			background-color: #ddffdd;
		}

		#loseScreen {
			text-align: center;
			background-image: none;
			background-color: #ffdddd;
		}

		#gameScreen > div {
			/*border: 1px solid black;*/
			box-sizing: border-box;
			float: left;
		}

		#gameMessageBox {
			height: 75%;
			width: 20%;
			padding-left: 25px;
			padding-right: 25px;
			padding-top: 80px;
		}

		#redText {
			color: red;
			font-size: 1.8em;
			position: absolute;
			top: 7px;
			left: 27px;
		}

		#blackText { 
			font-size: 1.8em;
			position: absolute;
			top: 5px;
			left: 25px;
		}

		#phaseDetail { font-size: 1.2em; }

		#moneyNum {
			font-size: 2.2em;
			margin-top: 20px;
			margin-bottom: 20px;
		}

		#gameHPBox {
			height: 10%;
			width: 80%;
			padding-top: 15px;
			padding-left: 80px;
		}

		#outerHP {
			height: 12px;
			width: 600px;
			border: 1px solid black;
			margin-right: 20px;
			float: left;
		}

		#innerHP {
			height: 100%;
			width: 100%;
			background-color: #ee88bb;
		}

		#numHP { float: left; }

		#gameMechBox, #gameMonsterBox {
			width: 20%;
			height: 65%;
		}

		#gameTileBox {
			width: 40%;
			height: 65%;
			padding-left: 30px;
			padding-top: 2px;
		}

		#gameTileBox > div {
			height: 81px;
			width: 81px;
			box-sizing: border-box;
			border-top: 1px solid black;
			border-left: 1px solid black;
			float: left;
			font-size: 0.8em;
			padding-left: 10px;
		}

		.rightTile { border-right: 1px solid black; }

		.bottomTile { border-bottom: 1px solid black; }

		#gameTileBox > div.fading { border-top: 1px dashed black; border-left: 1px dashed black; }
		.fading.rightTile { border-right: 1px dashed black; }
		.fading.bottomTile { border-bottom: 1px dashed black; }
		#gameTileBox > div.fadingg { border-top: 1px dotted black; border-left: 1px dotted black; }
		.fadingg.rightTile { border-right: 1px dotted black; }
		.fadingg.bottomTile { border-bottom: 1px dotted black; }

		.tileImage {
			font-family: "Courier New";
			float: left;
			margin-right: 15px;
			padding-top: 5px;
		}

		.tileHP {
			font-size: 1.6em;
			color: purple;
			text-align: right;
			padding-right: 10px;
		}

		#gameCardBox {
			overflow-x: scroll;
			width: 90%;
			height: 25%;
			text-align: center;
			white-space: nowrap;
		}

		#gameCardBox > div {
			display: inline-block;
		}

		#gameScreen > button {
			margin-left: 10px;
			margin-top: 30px;
		}

		#tileZoom, #cardZoom {
			display: none;
			position: absolute;
			border: 1px solid black;
			background-color: white;
			text-align: center;
		}

		#cardZoom {
			top: 140px;
			left: 180px;
			width: 225px;
			height: 240px;
			padding: 15px;
		}

		#cardZoom > button { margin: 15px; }

		#tileZoom {
			top: 100px;
			left: 240px;
			width: 600px;
			height: 300px;
			padding: 25px;
			overflow-y: scroll;
		}

		#tileZoom > button { margin: 15px; }

		.projectileTemplate, .smallProjectileTemplate {
			display: none;
			position: absolute;
			background-color: green;
		}

		.projectileTemplate {
			width: 20px;
			height: 20px;
		}

		.smallProjectileTemplate {
			width: 10px;
			height: 10px;
		}

		.blackBar {
			display: none;
			position: absolute;
			background-color: black;
			width: 192px;
			height: 10px;
			left: 768px;
		}

		#laserBar {
			display: none;
			position: absolute;
			background-color: green;
			top: 109px;
			left: 380px;
			height: 2px;
			width: 410px;
		}
		
	</style>
</head>
<body>
	<div id="mainScreen">
		<div id="mainTitle">
			<em><h1 class="bigWord">Kaiju Card</h1></em>
			<p>by Tony Youssef</p>
		</div>
		<div id="mainButtons">
			
			<hr>
			<p>Current deck:   
			<select id="deckSelect">
				<option value = "(Basic) Burn">(Basic) Burn</option>
				<option value = "(Basic) Money">(Basic) Money</option>
				<option value = "(Basic) Turrets">(Basic) Turrets</option>
			</select></p>
			
			<hr>
			<p></p>
			<button onclick="newDeck()">New Deck</button>
			<button onclick="editDeck()">Edit Deck</button>
			<button onclick="rules()">Rules</button>
			<p></p>
			<button onclick="beginNormal()">New Game (Normal)</button>
			<button onclick="beginHard()">New Game (Hard)</button>
		</div>
	</div>

	<div id="ruleScreen">
		<div id="ruleTitle">
		<button onclick="rulesToMain()">Back to Main Menu</button>
		<h1>Rules</h1>
		</div>
		<div id="ruleText">
			<strong><p>Overview</p></strong>
			<p>Your aim is to defend your city against a destructive monster. Your city map is represented by 16 tiles - walls, banks, guns, a church, a power plant, a statue, and a farm. You can build improvements on your city tiles and you can also command a giant mech to fire its weapons at the monster (all of this is done using the cards in your hand).</p>
			<hr>
			<strong><p>Example of Play</p></strong>
			<p>Let's say you start the game with $50 and you have Eat ($0, Farm) and Concuss ($40, None) in your hand, along with some other cards.</p>
			<p>You click on the card 'Eat' in your hand and a window pops up telling you what the card does. In this window, you click the Cast button. Since Eat has a target of 'Farm', you now have to click on a Farm tile in your city to complete the casting process.</p>
			<p>Eat cost $0, so you still have $50 left. Next, you click on the card 'Concuss' in your hand. A window pops up telling you what this card does, and you click the Cast button. Since Concuss has a target of 'None', it is immediately cast. $40 is then deducted from your money.</p>
			<p>You have $10 left, but it's not enough to cast any of your other cards, so you click on End Turn. This $10 goes to waste, but next turn you will have $60 to spend (assuming none of your banks just got destroyed!)</p>
			<hr>
			<strong><p>Deck Editor</p></strong>
			<p>Click on a card to read its text.</p>
			<p>Your deck must have exactly 40 cards with at most 5 copies of each card.</p>
			<p>Click a card name on the right side of the screen to scroll to that card.</p>
			<p>You can't delete or overwrite the three (Basic) decks.</p>
			<hr>
			<strong><p>Money</p></strong>
			<p>Your base income starts at 10 and goes up by 10 every turn. Banks generate an additional 10 income each, and some tiles can be improved to generate more income.</p>
			<p>Money that you don't spend isn't carried over between turns. At the start of each turn, it's set to your income.</p>
			<hr>
			<strong><p>Casting Phase</p></strong>
			<p>You start with 4 cards in hand and draw 2 new cards each turn.</p>
			<p>Click on a tile to see what its current stats and effects are. Click on a card to read its text and to get the option to cast it.</p>
			<p>Cards with "None" take effect immediately (unless they require you to discard cards). Other cards require you to select a target tile after casting. Cards with "Any" can target any non-destroyed tile. Cards with "Rubble" can only target destroyed tiles. If a card's location line is blacked out, that card can't be cast right now.</p>
			<p>Destroyed tiles lose all beneficial effects you have added to them. When rebuilt, they go back to their default stats (except for their hit points, and the effects of Eat and Safety cards).</p>
			<p>If your deck runs out of cards, a new copy of your deck is created and shuffled for you to draw from.</p>
			<hr>
			<strong><p>Turrets and Monster Actions</p></strong>
			<p>Your turrets fire for 10 damage each at the end of each turn. Gun tiles start with 1 turret.</p>
			<p>After your turrets fire, the monster attacks. On the first turn, the monster will attack random tiles 4 times, dealing 1 damage with each attack.</p>
			<p>Tiles with high threat are 5x more likely to be attacked than other tiles. Tiles with low threat are 5x less likely to be attacked. The statue starts with high threat.</p>
			<p>When the monster rampages, it attacks 7 times. The monster also has rare attacks which ignore some attack modifiers.</p>
			<hr>
			<strong><p>Other Tiles</p></strong>
			<p>The walls and the church have no special abilities. However, there are some cards that can only be used on the church (and so can't be used if your church has been destroyed). The background color of each card depends on what kind of tile it can target.</p>
			<p>When the plant is destroyed, it deals damage to random tiles 6 times - similar to the monster's attacks, but doesn't take threat into account.</p>
			<p>When the farm is destroyed, the monster heals 120hp, but can't be healed above its starting health.</p>
			<hr>
			<strong><p>Winning and Losing</p></strong>
			<p>When the monster is reduced to 0 hit points, you win!</p>
			<p>If all the city tiles are destroyed, the game is over.</p>
			<p>Playing on hard mode gives the monster 150 extra hit points to start with, and increases the chance of rampaging from 45% to 60%.</p>
		</div>
	</div>

	<div id="deckScreen">
		<div id="deckTitle">
		<div><span id="deckNameDeck"></span>  
			<button onclick="deckToMain()">Back to Main Menu (without saving)</button>
		</div>
		<button onclick="saveOverF()" id="saveOver">Save (overwrite)</button>
		<button onclick="saveNewF()" id="saveNew">Save as new deck</button>
		<button onclick="delDeckF()" id="delDeck">Delete deck</button>
		</div>
		<div id="deckLibrary">
			<div class="libraryItem">
				<div class="libraryNum">0</div>
				<div class="card">
					<strong><p class="cardName"></p></strong>
					<p class="cardCost"></p>
					<p class="cardLocation"></p>
					<p class="cardText"></p>
				</div>
				<div>
					<button class="add1">Add 1</button>
					<button class="add5">Add 5</button>
					<button class="remove1">Remove 1</button>
					<button class="remove5">Remove 5</button>
				</div>
			</div>
		</div>
		<div id="deckList">
			<strong><p>Total cards <span id="totalCards">0</span>/40</p></strong>
			<p class="listItem"><span class="listNum">0</span> <span class="listName"></span></p>
		</div>
		<div id="cardPopupDeck">
			<strong><p id="cardNameLg"></p></strong>
			<p id="cardTextLg"></p>
			<button class="add1">Add 1</button>
			<button class="add5">Add 5</button>
			<button class="remove1">Remove 1</button>
			<button class="remove5">Remove 5</button>
			<button id="cancelLg" onclick="cancelLg()">Close</button>
		</div>
		<div id="savePopup">
			<div id="saveTip"></div>
			<input type="text" id="saveName" onkeyup="saveEnter()">
			<div>
				<button onclick="saveOK()">OK</button>
				<button onclick="saveCancel()">Cancel</button>
			</div>
		</div>
	</div>

	<div id="winScreen">
		<h1 class="bigWord">You Win!</h1>
		<p>The city is safe.</p>
		<button onclick="winToMain()">Back to Main Menu</button>
	</div>

	<div id="loseScreen">
		<h1 class="bigWord">Game Over</h1>
		<p>The city is destroyed.</p>
		<button onclick="loseToMain()">Back to Main Menu</button>
	</div>

	<div id="gameScreen">
		<div id="gameMessageBox">
			<p id="redText"></p>
			<p id="blackText"></p>
			<hr>
			<p id="turnNum"></p>
			<p id="incomeNum"></p>
			<p id="energyNum"></p>
			<hr>
			<p id="moneyNum"></p>
			<hr>
			<p id="phaseDetail"></p>
			<button id="cancelTarget" onclick="cancelTargetF()">Cancel</button>
		</div>
		<div id="gameHPBox">
			<div id="outerHP"><div id="innerHP"></div></div><div id="numHP"></div>
		</div>
		<div id="gameMechBox">
			<canvas width="192" height ="351"></canvas>
		</div>
		<div id="gameTileBox">
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div></div><div></div><div></div><div class="rightTile"></div>
			<div class="bottomTile"></div><div class="bottomTile"></div><div class="bottomTile"></div><div class="bottomTile rightTile"></div>
		</div>
		<div id="gameMonsterBox">
			<canvas width="192" height ="351"></canvas>
		</div>
		<div id="gameCardBox">

		</div>
		<button onclick="endTurn()">End Turn</button>
		<div id="tileZoom">
			<strong><p id="zoomTileName"></p></strong>
			<p id="zoomTileDetails"></p>
			<p id="zoomTileEffects"></p>
			<button onclick="cancelTileZoom()">Close</button>
		</div>
		<div id="cardZoom">
			<strong><p id="zoomCardName"></p></strong>
			<p id="zoomCardText"></p>
			<button id="castClick" onclick="castClickF()">Cast</button>
			<button onclick="cancelCardZoom()">Close</button>
		</div>
		<div class="projectileTemplate"></div>
		<div class="smallProjectileTemplate"></div>
		<div class="blackBar"></div>
		<div id="laserBar"></div>
	</div>

<script type="text/javascript">
	mainScreen = document.getElementById("mainScreen");
	ruleScreen = document.getElementById("ruleScreen");
	gameScreen = document.getElementById("gameScreen");
	deckNameDeck = document.getElementById("deckNameDeck");
	deckSelect = document.getElementById("deckSelect");
	saveOver = document.getElementById("saveOver");
	saveNew = document.getElementById("saveNew");
	delDeck = document.getElementById("delDeck");
	savePopup = document.getElementById("savePopup");
	saveTip = document.getElementById("saveTip");
	saveName = document.getElementById("saveName");
	libraryItem = document.querySelector(".libraryItem");
	deckLibrary = document.getElementById("deckLibrary");
	listItem = document.querySelector(".listItem");
	deckList = document.getElementById("deckList");
	totalCards = document.getElementById("totalCards");
	cardPopupDeck = document.getElementById("cardPopupDeck");
	cardTextLg = document.getElementById("cardTextLg");
	cardNameLg = document.getElementById("cardNameLg");
	gameCardBox = document.getElementById("gameCardBox");
	numHP = document.getElementById("numHP");
	innerHP = document.getElementById("innerHP");
	turnNum = document.getElementById("turnNum");
	incomeNum = document.getElementById("incomeNum");
	energyNum = document.getElementById("energyNum");
	moneyNum = document.getElementById("moneyNum");
	phaseDetail = document.getElementById("phaseDetail");
	cancelTarget = document.getElementById("cancelTarget");
	tileZoom = document.getElementById("tileZoom");
	zoomTileName = document.getElementById("zoomTileName");
	zoomTileDetails = document.getElementById("zoomTileDetails");
	zoomTileEffects = document.getElementById("zoomTileEffects");
	cardZoom = document.getElementById("cardZoom");
	zoomCardName = document.getElementById("zoomCardName");
	zoomCardText = document.getElementById("zoomCardText");
	castClick = document.getElementById("castClick");
	projectileTemplate = document.querySelector(".projectileTemplate");
	smallProjectileTemplate = document.querySelector(".smallProjectileTemplate");
	blackBar = document.querySelector(".blackBar");
	gameHPBox = document.getElementById("gameHPBox");
	laserBar = document.getElementById("laserBar");

	var cardDictionary = {
		Ancestors: {
			cost: 40,
			location: "None",
			text: "Draw 3 cards",
			cast: function() { drawCard(); drawCard(); drawCard(); }
		},
		Battery: {
			cost: 40,
			location: "Any",
			text: "Mech gets +1 energy. Limit 1 battery per tile",
			cast: function() {				
				addEnergy(1);
				currentTile.batt = true;
				currentTile.effects.push({
					desc: function() { return "Mech gets +1 energy"; },
					func: function() { addEnergy(-1); },
					duration: -1
				});
			}
		},
		Bells: {
			cost: 10,
			location: "Church",
			text: "Church gets high threat for 1 turn. Draw a card",
			cast: function() {
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(5);
				currentTile.effects.push({
					desc: function() { return "High threat"; },
					func: null,
					duration: 1
				});
				drawCard();
			}
		},
		"Black Hole": {
			cost: 90,
			location: "None",
			text: "The monster loses 25% of its current hp",
			cast: function() { shoot(Math.ceil(monsterHP * 0.25)); }
		},
		Build: {
			cost: 50,
			location: "Any",
			text: "Tile gets +1 hp",
			cast: function() { currentTile.addHP(1); }
		},
		"Build+": {
			cost: 100,
			location: "Any",
			text: "Tile gets +2 hp",
			cast: function() { currentTile.addHP(2); }
		},
		Burn: {
			cost: 20,
			location: "None",
			text: "Deal 40 damage",
			cast: function() { shoot(40); }
		},
		"Burn+": {
			cost: 50,
			location: "None",
			text: "Deal 70 damage",
			cast: function() { shoot(70); }
		},
		Concuss: {
			cost: 40,
			location: "None",
			text: "Deal 10 damage. Monster attacks 1 less time next turn, up to 3 less normal attacks per turn",
			restricted: function() { return (reducedAttacks == 3); },
			cast: function() { shoot(10); reducedAttacks += 1; }
		},
		"Cow Launcher": {
			cost: 40,
			location: "Farm",
			text: "Add 2 turrets to your farm for 3 turns",
			cast: function() {
				var n = currentTile;
				n.guns += 2;
				currentTile.effects.push({
					desc: function() { return "2 temporary turrets"; },
					func: function() { n.guns -= 2; },
					duration: 3
				});
			}
		},
		Distract: {
			cost: 10,
			location: "None",
			text: "Monster heals 40hp. Monster attacks 1 less time next turn, up to 3 less normal attacks per turn",
			restricted: function() { return (reducedAttacks == 3 || monsterMaxHP - monsterHP < 40); },
			cast: function() { addMonsterHP(40); reducedAttacks += 1; }
		},
		"Divine Favor": {
			cost: 80,
			location: "Church",
			text: "Draw an extra card each turn. Stacks twice",
			restricted: function() { return (cardsPerTurn == 4); },
			cast: function() {
				cardsPerTurn += 1;
				currentTile.effects.push({
					desc: function() { return "Draw an extra card each turn"; },
					func: function() { cardsPerTurn -= 1; },
					duration: -1
				});
			}
		},
		"Divine Protection": {
			cost: 100,
			location: "Church",
			text: "1 less attack whenever the monster rampages. Stacks twice",
			restricted: function() { return (reducedRampage == 2); },
			cast: function() {
				reducedRampage += 1;
				currentTile.effects.push({
					desc: function() { return "-1 attack on rampage"; },
					func: function() { reducedRampage -= 1; },
					duration: -1
				});
			}
		},
		Eat: {
			cost: 0,
			location: "Farm",
			text: "Reduce farm's monster healing by 40. Stacks thrice",
			restricted: function() { return (farmNum == 0); },
			cast: function() { farmNum -= 40; }
		},
		Explosion: {
			cost: 70,
			location: "Any",
			text: "Deal 1 damage to your own tile and 150 damage to the monster",
			cast: function() {
				var n = tiles.indexOf(currentTile);
				currentTile.addHP(-1);
				tileShotQueue.push({
					tileNum: n,
					damage: 150
				});
				if (gameMode != "animating") tilesShoot();
			}
		},
		Gamble: {
			cost: 20,
			location: "None",
			text: "You have a 50% chance to gain $40 this turn",
			cast: function() {
				if (Math.random() < 0.5) {
					blackText.textContent = "Yay! :)";
					addMoney(40);
				} else blackText.textContent = "No! :(";
			}
		},
		"Golden Gun": {
			cost: 40,
			location: "Bank",
			text: "Deal 50 damage. This bank gains high threat for 2 turns",
			cast: function() {
				shoot(50);
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(5);
				currentTile.threat.push(5);
				currentTile.effects.push({
					desc: function() { return "High threat"; },
					func: null,
					duration: 2
				});
			}
		},
		Grant: {
			cost: 0,
			location: "None",
			text: "Gain $10 this turn",
			cast: function() { addMoney(10); }
		},
		"Hidden Turret": {
			cost: 50,
			location: "Any",
			text: "Tile gets low threat for 1 turn. Tile gets a turret",
			cast: function() {
				if (currentTile.threat.length > 1)
					currentTile.threat.splice(-1);
				currentTile.threat.push(0.2);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 1
				});
				currentTile.guns += 1;
			}
		},
		Income: {
			cost: 30,
			location: "Bank",
			text: "Bank generates +$10/turn",
			cast: function() { currentTile.income += 10; addIncome(10); }
		},
		"Income+": {
			cost: 60,
			location: "Bank",
			text: "Bank generates +$20/turn",
			cast: function() { currentTile.income += 20; addIncome(20); }
		},
		Laser: {
			cost: 60,
			location: "None",
			text: "Deal 40 damage for each energy you have",
			cast: function() { laserAnim(energy * 40); }
		},
		"Laser+": {
			cost: 120,
			location: "None",
			text: "Deal 70 damage for each energy you have",
			cast: function() { laserAnim(energy * 70); }
		},
		Loan: {
			cost: 0,
			location: "None",
			discard: 2,
			text: "Discard 2 cards. Gain $20 this turn",
			cast: function() { addMoney(20); }
		},
		Market: {
			cost: 90,
			location: "Farm",
			text: "Farm generates +$30 per turn",
			cast: function() { currentTile.income += 30; addIncome(30); }
		},
		Melt: {
			cost: 20,
			location: "None",
			text: "Spend all your remaining money this turn. Deal that much damage",
			restricted: function() { return (money == 20); },
			cast: function() { shoot(money); addMoney(-money); }
		},
		Missile: {
			cost: 30,
			location: "None",
			text: "Deal 30 damage and draw a card",
			cast: function() { shoot(30); drawCard(); }
		},
		"Missile+": {
			cost: 60,
			location: "None",
			text: "Deal 40 damage and draw 2 cards",
			cast: function() { shoot(40); drawCard(); drawCard(); }
		},
		"Missile++": {
			cost: 80,
			location: "None",
			text: "Deal 60 damage and draw 3 cards",
			cast: function() { shoot(60); drawCard(); drawCard(); drawCard(); }
		},
		"Multi Turret": {
			cost: 90,
			location: "None",
			text: "3 times, add a turret to a random tile",
			cast: function() {
				for (var j = 0; j < 3; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].guns += 1;
						tiles[x].flash();
					}
				}
			}
		},
		"Multi Turret+": {
			cost: 100,
			location: "None",
			text: "4 times, add a turret to a random tile",
			cast: function() {
				for (var j = 0; j < 4; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].guns += 1;
						tiles[x].flash();
					}
				}
			}
		},
		Power: {
			cost: 80,
			location: "Plant",
			text: "Mech gets +2 energy for 6 turns",
			cast: function() {
				addEnergy(2);
				currentTile.effects.push({
					desc: function() { return "Mech gets +2 energy"; },
					func: function() { addEnergy(-2); this.expire = false; },
					duration: 6,
					expire: true
				});
			}
		},
		Rebuild: {
			cost: 100,
			location: "Rubble",
			text: "Rebuild a destroyed tile. It gets 2hp",
			cast: function() { resetTile(currentTile); currentTile.addHP(2 - currentTile.hp); }
		},
		Reinforce: {
			cost: 80,
			location: "None",
			text: "2 times, a random tile gets +1hp",
			cast: function() {
				for (var j = 0; j < 2; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		},
		"Reinforce +": {
			cost: 110,
			location: "None",
			text: "3 times, a random tile gets +1hp",
			cast: function() {
				for (var j = 0; j < 3; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		},
		Rig: {
			cost: 10,
			location: "Any",
			text: "If this tile is destroyed in the next 2 turns, it deals 50 damage to the monster",
			cast: function() {
				var n = currentTile;
				n.explo += 50;
				n.effects.push({
					desc: function() { return "When destroyed, deal 50 damage"; },
					func: function() { n.explo -= 50; },
					duration: 2
				});
			}
		},
		Safety: {
			cost: 50,
			location: "Plant",
			text: "Reduce plant's explosion damage by 3. Stacks twice",
			restricted: function() { return (plantNum == 0); },
			cast: function() { plantNum -= 3; }
		},
		Savings: {
			cost: 20,
			location: "None",
			text: "Any unspent money this turn carries over to next turn",
			restricted: function() { return saveMoney; },
			cast: function() { saveMoney = true; }
		},
		"Secret Project": {
			cost: 120,
			location: "Rubble",
			text: "Rebuild a destroyed tile. It gets 2hp. It gains low threat for 3 turns",
			cast: function() {
				resetTile(currentTile);
				currentTile.addHP(2 - currentTile.hp);
				currentTile.threat.push(0.2);
				currentTile.threat.push(0.2);
				currentTile.threat.push(0.2);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 3
				});
			}
		},
		Shiny: {
			cost: 20,
			location: "Any",
			text: "Tile gets high threat",
			cast: function() { currentTile.threat = [5]; }
		},
		Sift: {
			cost: 0,
			location: "None",
			discard: 2,
			text: "Discard 2 cards, then draw 2 cards",
			cast: function() { drawCard(); drawCard(); }
		},
		Stealth: {
			cost: 30,
			location: "Any",
			text: "Tile gets low threat for 3 turns",
			cast: function() {
				for (var j = 0; j < 3; j++)
					if (currentTile.threat.length > 1)
						currentTile.threat.splice(-1);
				for (var j = 0; j < 3; j++)
					currentTile.threat.push(0.2);
				currentTile.effects.push({
					desc: function() { return "Low threat"; },
					func: null,
					duration: 3
				});
			}			
		},
		Surge: {
			cost: 100,
			location: "Plant",
			text: "Deal 1 damage to your plant and 200 damage to the monster",
			cast: function() {
				var n = tiles.indexOf(currentTile);
				currentTile.addHP(-1);
				tileShotQueue.push({
					tileNum: n,
					damage: 200
				});
				if (gameMode != "animating") tilesShoot();
			}
		},
		Sword: {
			cost: 0,
			location: "None",
			text: "Deal 20 damage",
			cast: function() { laserAnim(20); }
		},
		"Time Travel": {
			cost: 170,
			location: "None",
			text: "Take an extra turn after this one",
			cast: function() { extraTurns += 1; }
		},
		"Tough Turret": {
			cost: 80,
			location: "Any",
			text: "Tile gets +1hp and a turret",
			cast: function() { currentTile.addHP(1); currentTile.guns += 1; }
		},
		Treasure: {
			cost: 30,
			location: "Bank",
			text: "When this bank is destroyed, gain $30 at the start of your next turn",
			cast: function() {
				currentTile.effects.push({
					desc: function() { return "When destroyed, gain $30 at the start of your next turn"; },
					func: function() { extraMoney += 30; },
					duration: -1
				});
			}
		},
		Turret: {
			cost: 30,
			location: "Any",
			text: "Tile gets another turret",
			cast: function() { currentTile.guns += 1; }
		},
		"Turret+": {
			cost: 70,
			location: "Any",
			text: "Tile gets 2 more turrets",
			cast: function() { currentTile.guns += 2; }
		},
		Volley: {
			cost: 50,
			location: "None",
			text: "Your turrets fire a volley",
			restricted: noTurrets,
			cast: volley
		},
		"Volley+": {
			cost: 100,
			location: "None",
			text: "Your turrets fire two volleys",
			restricted: noTurrets,
			cast: function() { volley(); qVolley = true; }
		},
		Weld: {
			cost: 100,
			location: "None",
			text: "For each energy you have, a random tile gets +1 hp",
			cast: function() {
				for (var j = 0; j < energy; j++) {
					var x = Math.floor(Math.random() * 16);
					if (tiles[x].hp == 0)
						j--;
					else {
						tiles[x].addHP(1);
						tiles[x].flash();
					}
				}
			}
		}
	};

	var colorType = {
		Any: "#dddddd",
		Bank: "#ffffaa",
		None: "#ffaaff",
		Church: "#bbbbff",
		Plant: "#cc99ff",
		Farm: "#aaffaa",
		Rubble: "#bbbbbb"
	};

	var basicDecks = {
		"(Basic) Burn": "5Burn5Burn+5Concuss5Eat5Explosion5Missile5Missile+5Sword",
		"(Basic) Money": "5Ancestors5Black Hole5Build5Grant5Income5Income+5Market5Melt",
		"(Basic) Turrets": "5Cow Launcher5Distract5Loan5Tough Turret5Turret5Turret+5Volley5Volley+"
	};

	var tileOrder = [
		"Wall", "Guns", "Bank", "Wall",
		"Bank", "Church", "Statue", "Guns",
		"Guns", "Plant", "Farm", "Bank",
		"Wall", "Bank", "Guns", "Wall"
	];

	var tileDictionary = {
		"Wall": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "##<br>##<br>##"
		},
		"Guns": {
			hp: 3,
			guns: 1,
			income: 0,
			image: "&nbsp;/<br>/o<br>##"
		},
		"Bank": {
			hp: 3,
			guns: 0,
			income: 10,
			image: "$$<br>__<br>##"
		},
		"Farm": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "__<br>__<br>__"
		},
		"Plant": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "||<br>/\\<br>##"
		},
		"Statue": {
			hp: 2,
			guns: 0,
			income: 0,
			image: "\\o<br>||<br>/\\"
		},
		"Church": {
			hp: 4,
			guns: 0,
			income: 0,
			image: "/\\<br>||<br>/\\"
		}
	};

	var overlay = false;
	var library = {};
	var total = 0;
	var deck, origDeck;
	var monsterHP, monsterMaxHP, rampageChance;
	var tiles = [];
	var gameMode;
	var currentCard, currentTile, nome;
	var income, money, turn, cardsPerTurn, energy;
	var saveMoney;
	var extraTurns, extraMoney;
	var plantNum, farmNum;
	var reducedAttacks, reducedRampage;
	var setAttacks, toHit;
	var qWin, qLose, qPlant, qVolley, qAttack, qBetween;
	var projectiles = 0;
	var winBarArray;
	var dist = 0;
	var tileShotQueue;
	
	drawMech();
	drawMonster();

	for (var i=0; i < localStorage.length; i++) addToList(localStorage.key(i));
	for (var el in cardDictionary) {
		node = libraryItem.cloneNode(true);
		node.querySelector(".cardName").textContent = el;
		node.querySelector(".cardCost").textContent = "$" + cardDictionary[el].cost;
		node.querySelector(".cardLocation").textContent = cardDictionary[el].location;
		node.querySelector(".cardText").textContent = cardDictionary[el].text;
		node.querySelector(".card").style["background-color"] = colorType[cardDictionary[el].location];

		node2 = listItem.cloneNode(true);
		node2.querySelector(".listName").textContent = el;
		createListListener(node2, dist++);

		library[el] = {
			quantity: 0,
			node: node,
			node2: node2,
			addCards: addCards
		};
		
		createAddListener(node.querySelector(".add1"), library[el], 1, true);
		createAddListener(node.querySelector(".add5"), library[el], 5, true);
		createAddListener(node.querySelector(".remove1"), library[el], -1, true);
		createAddListener(node.querySelector(".remove5"), library[el], -5, true);
		createCardListener(node.querySelector(".card"), el);
		deckLibrary.appendChild(node);
		deckList.appendChild(node2);
	}
	libraryItem.style.display = "none";

	var tileDivs = document.querySelectorAll("#gameTileBox > div");
	for (var i = 0; i < 16; i++) {
		node = tileDivs[i];
		tileName = tileOrder[i];
		tiles.push({
			node: node,
			nome: tileName,
			hp: 0,
			income: 0,
			guns: 0,
			explo: 0,
			batt: false,
			addHP: function(amount) {
				if (this.hp == 0) return;
				this.hp += amount;
				this.node.querySelector(".tileHP").textContent = this.hp;
				if (this.hp == 0) {
					if (this.timer) clearTimeout(this.timer);
					this.node.style["background-color"] = "#bbbbbb";
					gameTileBox.style["padding-left"] = "34px";
					setTimeout(function() { gameTileBox.style["padding-left"] = "30px"; }, 130);
					addIncome(-this.income);
					if (playerLost()) {
						if (gameMode == "animating") qLose = true; else gameOver();
					}
					for (var j = 0; j < this.effects.length; j++) {
						if (this.effects[j].duration == -1 || this.effects[j].expire) this.effects[j].func();
					}
					if (this.explo > 0) {
						tileShotQueue.push({
							tileNum: tiles.indexOf(this),
							damage: this.explo
						});
						if (gameMode != "animating") tilesShoot();
					}
				}
			},
			flash: function() {
				var n = this.node;
				n.style["background-color"] = "yellow";
				this.timer = setTimeout(function() { n.style["background-color"] = ""; this.timer = null; }, 130);
			},
			lastThreat: function() { return this.threat[this.threat.length - 1]; }
		});
		newP = document.createElement("p");
		newP.innerHTML = tileDictionary[tileName].image;
		newP.classList.add("tileImage");
		node.appendChild(newP);
		newP = document.createElement("p");
		newP.textContent = tileName;
		node.appendChild(newP);
		newP = document.createElement("p");
		newP.classList.add("tileHP");
		node.appendChild(newP);
		createTileListener(tiles[i]);
	}

	kongregateAPI.loadAPI(function(){
		window.kongregate = kongregateAPI.getAPI();
	});

	function resetTile(tile) {
		tile.hp = tileDictionary[tile.nome].hp;
		tile.income = tileDictionary[tile.nome].income;
		addIncome(tileDictionary[tile.nome].income);
		tile.guns = tileDictionary[tile.nome].guns;
		tile.explo = 0;
		tile.batt = false;
		tile.node.style["background-color"] = "";
		tile.node.querySelector(".tileHP").textContent = tile.hp;
		if (tile.nome == "Statue")
			tile.threat = [5];
		else
			tile.threat = [1];
		tile.effects = [];
		if (tile.nome == "Plant") tile.effects.push({
			desc: function() { return "When destroyed, damage random tiles " + plantNum + " times"; },
			func: function() {
				if (gameMode == "animating") qPlant = true; else plantExplosion();
			},
			duration: -1
		});
		if (tile.nome == "Farm") tile.effects.push({
			desc: function() { return "When destroyed, the monster heals " + farmNum + " hp"; },
			func: function() {
				if (farmNum > 0) {
					addMonsterHP(farmNum);
					gameHPBox.style["background-color"] = "lime";
					setTimeout(function() { gameHPBox.style["background-color"] = ""; }, 260);
				}
			},
			duration: -1
		});
	}

	function createTileListener(tile) {
		tile.node.onclick = function() {
			if (gameMode == "targetting" && legalTarget(tile, nome)) {
				currentTile = tile;
				tile.flash();
				cast();
			} else if (gameMode == "casting") {
				setMode("zooming");
				nameStr = tile.nome;
				if (tile.lastThreat() == 5) nameStr += " - high threat";
				if (tile.lastThreat() == 0.2) nameStr += " - low threat";
				nameStr += " - " + tile.hp + " hit points";
				zoomTileName.textContent = nameStr;
				zoomTileDetails.textContent = "Turrets: " + tile.guns + " --- Income: $" + tile.income + " per turn";
				fxStr = "";			
				for (var j = 0; j < tile.effects.length; j++) {
					if (j > 0) fxStr += "; ";
					fxStr += tile.effects[j].desc();
					if (tile.effects[j].duration > -1)
						fxStr += " (" + tile.effects[j].duration + " turns)";
				}
				if (fxStr == "")
					zoomTileEffects.textContent = "";
				else
					zoomTileEffects.textContent = "Effects: " + fxStr;
				tileZoom.style.display = "block";
			}
		}
	}

	function legalTarget(tile, cardName) {
		if (tile.hp == 0) return (cardDictionary[cardName].location == "Rubble");
		if (cardName == "Battery" && tile.batt == true) return false;
		if (cardDictionary[cardName].location == "Any") return true;
		return (cardDictionary[cardName].location == tile.nome);
	}

	function createListListener(item, dist) {
		item.onclick = function() { deckLibrary.scrollTop = deckLibrary.scrollHeight * dist / 52; }
	}

	function createAddListener(button, obj, quantity, preventOnOverlay) {
		button.onclick = function(){
			if (overlay && preventOnOverlay) return;
			obj.addCards(quantity);
		};
	}

	function createCardListener(card, el) {
		card.onclick = function(){
			if(overlay) return;
			cardPopupDeck.style.display = "block";
			overlay = true;
			cardNameLg.textContent = el + " - $" + cardDictionary[el].cost + " - " + cardDictionary[el].location;
			cardTextLg.textContent = cardDictionary[el].text;
			createAddListener(cardPopupDeck.querySelector(".add1"), library[el], 1, false);
			createAddListener(cardPopupDeck.querySelector(".add5"), library[el], 5, false);
			createAddListener(cardPopupDeck.querySelector(".remove1"), library[el], -1, false);
			createAddListener(cardPopupDeck.querySelector(".remove5"), library[el], -5, false);
		};
	}

	function addCards(quantity) {
		newQ = this.quantity + quantity;
		if (newQ > 5) newQ = 5;
		if (newQ < 0) newQ = 0;
		addTotal(newQ - this.quantity);
		this.quantity = newQ;
		if (this.quantity == 0) this.node2.style.display = "none";
		else this.node2.style.display = "block";
		this.node2.querySelector(".listNum").textContent = this.quantity;
		this.node.querySelector(".libraryNum").textContent = this.quantity;
	}

	function addTotal(n) {
		total += n;
		totalCards.textContent = total;
		if (total < 40) totalCards.style.color = "red";
		if (total > 40) totalCards.style.color = "purple";
		if (total == 40) {
			totalCards.style.color = "green";
			saveNew.disabled = false;
			if (!delDeck.disabled) saveOver.disabled = false;
		} else {
			saveNew.disabled = true;
			saveOver.disabled = true;
		}
	}

	function cancelLg() {
		cardPopupDeck.style.display = "none";
		overlay = false;
	}

	function rules() {
		mainScreen.style.display = "none";
		ruleScreen.style.display = "block";
	}

	function newDeck() {
		deckNameDeck.textContent = "Untitled deck";
		saveOver.disabled = true;
		delDeck.disabled = true;
		resetLibrary();
		mainScreen.style.display = "none";
		deckScreen.style.display = "block";
	}

	function editDeck() {
		deckNameDeck.textContent = deckSelect.value;
		resetLibrary();
		if (basicName(deckSelect.value)) {
			saveOver.disabled = true;
			delDeck.disabled = true;
			loadDeck(basicDecks[deckSelect.value], false);
		} else {
			delDeck.disabled = false;
			loadDeck(localStorage.getItem(deckSelect.value), false);
		}
		mainScreen.style.display = "none";
		deckScreen.style.display = "block";
	}

	function resetLibrary() {
		for (el in library) {
			library[el].addCards(-5);
		}
	}

	function saveDeck() {
		var str = "";
		for (el in library)
			if (library[el].quantity > 0) str += library[el].quantity + el;
		return str;
	}

	function loadDeck(str, loadToDeck) {
		var substr = "";
		var c;
		var x = str.charAt(0);
		for (var i = 1; i < str.length; i++) {
			c = str.charAt(i);
			if (c >= '0' && c <= '9') {
				if (loadToDeck) {
					for (var j = 0; j < Number(x); j++)
						deck.push(substr);
				} else
					library[substr].addCards(Number(x));
				x = c;
				substr = "";
			} else substr += c;
		}
		if (loadToDeck) {
			for (var j = 0; j < Number(x); j++)
				deck.push(substr);
		} else
			library[substr].addCards(Number(x));
	}

	function beginNormal() {
		monsterMaxHP = 1450;
		rampageChance = 0.45;
		newGame();
	}

	function beginHard() {
		monsterMaxHP = 1600;
		rampageChance = 0.6;
		newGame();
	}

	function newGame() {
		deck = [];
		if (basicName(deckSelect.value)) {
			loadDeck(basicDecks[deckSelect.value], true);
		} else {
			loadDeck(localStorage.getItem(deckSelect.value), true);
		}
		origDeck = deck.slice(0);
		shuffle();
		while (gameCardBox.firstChild)
    		gameCardBox.removeChild(gameCardBox.firstChild);
		drawCard();
		drawCard();
		plantNum = 6;
		farmNum = 120;
		reducedRampage = 0;
		extraTurns = 0;
		toHit = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		tileShotQueue = [];
		qWin = false;
		qLose = false;
		qPlant = false;
		qVolley = false;
		qAttack = false;
		qBetween = false;
		redText.textContent = "";
		blackText.textContent = "";
		monsterHP = 0;
		addMonsterHP(monsterMaxHP);
		energy = 0;
		addEnergy(1);
		income = 0;
		turn = 0;
		cardsPerTurn = 2;
		saveMoney = false;
		extraMoney = 0;
		for (var i = 0; i < tiles.length; i++) resetTile(tiles[i]);
		setMode("casting");
		newTurn();
		
		mainScreen.style.display = "none";
		gameScreen.style.display = "block";
	}

	function shuffle() {
		var temp, rnd;
		for (var i = 0; i < deck.length; i++) {
			rnd = Math.floor(Math.random() * (deck.length - i)) + i;
			temp = deck[i];
			deck[i] = deck[rnd];
			deck[rnd] = temp;
		}
	}

	function newTurn() {
		for (var j = 0; j < cardsPerTurn; j++) drawCard();
		if (!saveMoney) money = 0;
		saveMoney = false;
		reducedAttacks = 0;
		addIncome(10);
		addMoney(income + extraMoney);
		extraMoney = 0;
		turn += 1;
		turnNum.textContent = "Turn " + turn;
		if (gameMode != "animating") setMode("casting");
	}

	function drawCard() {
		if (deck.length == 0) {
			deck = origDeck.slice(0);
			shuffle();
		}
		cardName = deck.pop();
		node = library[cardName].node.querySelector(".card").cloneNode(true);
		gameCardBox.appendChild(node);
		createCardInHandListener(node, cardName);
		gameCardBox.scrollLeft = gameCardBox.scrollWidth;
	}

	function castableAll() {
		var cardDivs = document.querySelectorAll("#gameCardBox > div");
		for (var j = 0; j < cardDivs.length; j++) {
			castable(cardDivs[j]);
		}
	}

	function castable(node) {
		var cardName = node.querySelector(".cardName").textContent;
		var stripe = node.querySelector(".cardLocation");
		if (cardDictionary[cardName].cost > money) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].discard && cardDictionary[cardName].discard > gameCardBox.childElementCount - 1) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].restricted && cardDictionary[cardName].restricted()) {
			stripe.classList.add("uncastable");
			return false;
		}
		if (cardDictionary[cardName].location == "None") {
			stripe.classList.remove("uncastable");
			return true;
		}
		for (var j = 0; j < 16; j++) {
			if (legalTarget(tiles[j], cardName)) {
				stripe.classList.remove("uncastable");
				return true;
			}
		}
		stripe.classList.add("uncastable");
		return false;
	}

	function createCardInHandListener(node, cardName) {
		node.onclick = function() {
			if (gameMode == "casting") {
				blackText.textContent = "";
				redText.textContent = "";
				currentCard = this;
				nome = cardName;
				setMode("zooming");
				zoomCardName.textContent = nome + " - $" + cardDictionary[nome].cost + " - " + cardDictionary[nome].location;
				zoomCardText.textContent = cardDictionary[nome].text;
				castClick.disabled = !castable(this);
				cardZoom.style.display = "block";
				castClick.focus();
			} else if (gameMode == "discarding" && this != currentCard) {
				setMode("discarding1");
				gameCardBox.removeChild(this);
			} else if (gameMode == "discarding1" && this != currentCard) {
				gameCardBox.removeChild(this);
				cast();
			}
		};
	}

	function cancelCardZoom() {
		cardZoom.style.display = "none";
		setMode("casting");
	}

	function castClickF() {
		cardZoom.style.display = "none";
		if (cardDictionary[nome].location == "None") {
			if (cardDictionary[nome].discard)
				setMode("discarding");
			else
				cast();
		} else {
			setMode("targetting");
		}		
	}

	function cast() {
		addMoney(-cardDictionary[nome].cost);
		cardDictionary[nome].cast();
		gameCardBox.removeChild(currentCard);
		castableAll();
		if (gameMode != "animating") setMode("casting");
	}

	function addMoney(amount) {
		money += amount;
		moneyNum.textContent = "$" + money;
	}

	function addIncome(amount) {
		income += amount;
		incomeNum.textContent = "Income: $" + income;
	}

	function addEnergy(amount) {
		energy += amount;
		energyNum.textContent = "Energy: " + energy;
	}

	function addMonsterHP(amount) {
		monsterHP += amount;
		if (monsterHP > monsterMaxHP) monsterHP = monsterMaxHP;
		if (monsterHP < 0) monsterHP = 0;
		numHP.textContent = monsterHP + "hp";
		innerHP.style.width = (100 * monsterHP / monsterMaxHP) + "%";
		if (amount < 0) {
			gameMonsterBox.style["padding-left"] = "4px";
			setTimeout(function() { gameMonsterBox.style["padding-left"] = ""; }, 130);
		}
		if (monsterHP == 0) {
			if (gameMode == "animating") qWin = true; else youWin();
		}
	}

	function shoot(amount) {
		setMode("animating");
		anim([{
			startX: 380,
			startY: 100,
			endX: 770,
			endY: 100,
			big: true,
			tile: null,
			damage: amount,
			shots: 1
		}], true);
	}

	function tilesShoot() {
		var array = [];
		for (var j = 0; j < tileShotQueue.length; j++) {
			array.push({
				startX: 445 + 81 * (tileShotQueue[j].tileNum % 4),
				startY: 90 + 81 * Math.floor(tileShotQueue[j].tileNum / 4),
				endX: 770,
				endY: 100,
				big: true,
				tile: null,
				damage: tileShotQueue[j].damage,
				shots: 1
			});
		}
		tileShotQueue = [];
		setMode("animating");
		anim(array, true);
	}

	function endTurn() {
		if (gameMode != "casting") return;
		volley();
		if (gameMode == "animating") qAttack = true; else attack();
		if (gameMode == "animating") qBetween = true; else betweenTurn();
	}

	function betweenTurn() {
		for (var i = 0; i < 16; i++) {
			if (tiles[i].hp > 0) {
				if (tiles[i].threat.length > 1) tiles[i].threat.pop();
				for (var j = tiles[i].effects.length - 1; j >= 0; j--) {
					if (tiles[i].effects[j].duration > 1) {
						tiles[i].effects[j].duration -= 1;					
					} else if (tiles[i].effects[j].duration == 1) {
						if (tiles[i].effects[j].func) tiles[i].effects[j].func();
						tiles[i].flash();
						tiles[i].effects.splice(j, 1);
					}
				}
			}

		}
		newTurn();
	}

	function volley() {
		if (noTurrets()) return;
		var array = [];
		setMode("animating");
		for (var i = 0; i < 16; i++) {
			if (tiles[i].hp > 0 && tiles[i].guns > 0) {
				array.push({
					startX: 450 + 81 * (i % 4),
					startY: 70 + 81 * Math.floor(i / 4),
					endX: 780,
					endY: 100,
					big: false,
					tile: null,
					damage: 10,
					shots: tiles[i].guns
				});
			}
		}
		anim(array, false);
	}

	function noTurrets() {
		for (var i = 0; i < 16; i++) {
			if (tiles[i].hp > 0 && tiles[i].guns > 0) return false;
		}
		return true;
	}

	function attack() {
		if (extraTurns > 0) {
			blackText.textContent = "Extra turn";
			extraTurns -= 1;
			checkQueues();
			return;
		}

		var rnd = turn == 1 ? 0.75 : Math.random();
		setAttacks = [];
		if (rnd >= 0.96) {
			blackText.textContent = "X attack!";
			redText.textContent = "X attack!";
			var rnd2;
			while (true) {
				rnd2 = 4 * Math.floor(Math.random() * 4);
				if (tiles[rnd2].hp > 0 || tiles[rnd2 + 1].hp > 0 || tiles[rnd2 + 2].hp > 0 || tiles[rnd2 + 3].hp > 0) break;
			}
			for (var i = 0; i < 4; i++) {
				setAttacks.push(rnd2 + i);
			}
		} else if (rnd >= 0.92) {
			blackText.textContent = "Y attack!";
			redText.textContent = "Y attack!";
			var rnd2;
			while (true) {
				rnd2 = Math.floor(Math.random() * 4);
				if (tiles[rnd2].hp > 0 || tiles[rnd2 + 4].hp > 0 || tiles[rnd2 + 8].hp > 0 || tiles[rnd2 + 12].hp > 0) break;
			}
			for (var i = rnd2; i < 16; i += 4) {
				setAttacks.push(i);
			}
		} else if (rnd >= 0.9) {
			blackText.textContent = "Z attack!";
			redText.textContent = "Z attack!";
			setAttacksByThreat(1);
			var x = setAttacks[0];
			setAttacks = [x, x, x, x];
		} else {
			var totalAttacks = 4 - reducedAttacks;
			if (rnd < rampageChance) totalAttacks += 3 - reducedRampage;
			if (rnd < rampageChance) {
				blackText.textContent = "RAMPAGE";
				redText.textContent = "RAMPAGE";
			} else {
				blackText.textContent = "";
				redText.textContent = "";
			}
			setAttacksByThreat(totalAttacks);
		}
		array = [];
		for (var i = 0; i < setAttacks.length; i++) {
			var x = setAttacks[i];
			toHit[x] = 0;
			array.push({
				startX: 770,
				startY: 90,
				endX: 445 + 81 * (x % 4),
				endY: 90 + 81 * Math.floor(x / 4),
				big: true,
				tile: tiles[x],
				damage: null,
				shots: 1
			});
		}
		setMode("animating");
		if (rnd >= 0.92) anim(array, false); else anim(array, true);
	}

	function setAttacksByThreat(numAttacks) {
		var totalThreat = 0;
		for (var i = 0; i < 16; i++)
			if (tiles[i].hp > 0) totalThreat += tiles[i].lastThreat();
		for (var i = 0; i < numAttacks; i++) {
			if (playerLost()) break;
			var threatTally;
			var rnd;
			while (true) {
				threatTally = 0;
				rnd = Math.random() * totalThreat;
				for (var j = 0; j < 16; j++) {
					if (tiles[j].hp > 0) {
						threatTally += tiles[j].lastThreat();
						if (threatTally > rnd) {
							if (tiles[j].hp - toHit[j] > 0) {
								toHit[j] += 1;
								setAttacks.push(j);
								break;
							} else j = 16;
						}
					}
				}
				if (j < 16) break;
			}
		}
	}

	function playerLost() {
		for (var j = 0; j < 16; j++)
			if (tiles[j].hp - toHit[j] > 0) return false;
		return true;
	}

	function setMode(str) {
		gameMode = str;
		phaseDetail.style.color = "";
		if (str == "targetting" || str == "discarding") {
			cancelTarget.disabled = false;
		} else {
			cancelTarget.disabled = true;
		}
		if (str == "casting") {
			phaseDetail.textContent = "Casting phase";
			castableAll();
		}
		if (str == "targetting") {
			currentCard.style.border = "1px dashed purple";
			phaseDetail.textContent = "Target: " + cardDictionary[nome].location;
			phaseDetail.style.color = "purple";
		}
		if (str == "animating")
			phaseDetail.textContent = "Please wait...";
		if (str == "discarding") {
			currentCard.style.border = "1px dashed purple";
			phaseDetail.textContent = "Discard 2 cards";
		}
		if (str == "discarding1")
			phaseDetail.textContent = "Discard 1 card";
	}

	function cancelTargetF() {
		setMode("casting");
		currentCard.style.border = "1px solid black";
	}

	function cancelTileZoom() {
		tileZoom.style.display = "none";
		setMode("casting");
	}

	function plantExplosion() {
		if (plantNum == 0 || playerLost()) {
			checkQueues();
			return;
		}
		var array = [];
		for (var j = 0; j < plantNum; j++) {
			if (playerLost()) break;
			var x = Math.floor(Math.random() * 16);
			if (tiles[x].hp - toHit[x] <= 0)
				j--;
			else {
				array.push({
					startX: 445 + 81,
					startY: 90 + 81 * 2,
					endX: 445 + 81 * (x % 4),
					endY: 90 + 81 * Math.floor(x / 4),
					big: true,
					tile: tiles[x],
					damage: null,
					shots: 1
				});
				toHit[x] += 1;
			}
		}
		for (var j = 0; j < 16; j++) toHit[j] = 0;
		setMode("animating");
		anim(array, true);
	}

	function youWin() {
		kongregate.stats.submit("Game Won", 1);
		if (rampageChance == 0.6) kongregate.stats.submit("Game Won (Hard)", 1);
		setMode("animating");
		var array = [];
		winBarArray = [];
		for (var j = 0; j < 33; j++) {
			winBarArray.push(blackBar.cloneNode(false));
			array.push(j);
		}
		for (var j = 0; j < 33; j++) {
			var x = Math.floor(Math.random() * (33 - j)) + j;
			createWinBar(array[x], j);
			array[x] = array[j];
		}
		setTimeout(function() {
			gameScreen.style.display = "none";
			winScreen.style.display = "block";
			for (var j = 0; j < 33; j++)
				gameScreen.removeChild(winBarArray[j]);
		}, 3700);
	}

	function createWinBar(x, j) {
		setTimeout(function() {
			winBarArray[j].style.top = (60 + 10 * j) + "px";
			winBarArray[j].style.display = "block";
			gameScreen.appendChild(winBarArray[j]);
		}, x * 100);
	}

	function gameOver() {
		kongregate.stats.submit("Game Lost", 1);
		setMode("animating");
		setTimeout(function() {
			for (var j=0; j < 16; j++) {
				tiles[j].node.style["background-color"] = "#cccccc";
				tiles[j].node.classList.add("fading");
			}
		}, 800);
		setTimeout(function() {
			for (var j=0; j < 16; j++) {
				tiles[j].node.style["background-color"] = "#dddddd";
				tiles[j].node.classList.add("fadingg");
			}
		}, 1600);
		setTimeout(function() {
			gameScreen.style.display = "none";
			loseScreen.style.display = "block";
			for (var j=0; j < 16; j++) {
				tiles[j].node.classList.remove("fadingg");
				tiles[j].node.classList.remove("fading");
			}
		}, 2400);
	}

	function winToMain() {
		winScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function loseToMain() {
		loseScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function addToList(name) {
		var option = document.createElement("option");
		option.text = name;
		option.value = name;
		deckSelect.add(option);
	}

	function rulesToMain() {
		ruleScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function deckToMain() {
		if (overlay) return;
		deckScreen.style.display = "none";
		mainScreen.style.display = "block";
	}

	function saveOverF() {
		localStorage.setItem(deckSelect.value, saveDeck());
		deckToMain();
	}

	function saveNewF() {
		if (overlay) return;
		overlay = true;
		saveTip.textContent = "Enter deck name"
		saveName.value = "";
		savePopup.style.display = "block";
		saveName.focus();
	}

	function saveCancel() {
		savePopup.style.display = "none";
		overlay = false;
	}

	function saveEnter() {
		if (event.key == "Enter") saveOK();
	}

	function saveOK() {
		if (saveName.value == "" || basicName(saveName.value) || localStorage.getItem(saveName.value)) {
			saveTip.textContent = "Invalid name. Enter deck name"
		} else {
			localStorage.setItem(saveName.value, saveDeck());
			addToList(saveName.value);
			savePopup.style.display = "none";
			overlay = false;
			deckSelect.options[deckSelect.length - 1].selected = true;
			deckToMain();
		}
	}

	function delDeckF() {
		localStorage.removeItem(deckSelect.value);
		for (var i = 0; i < deckSelect.options.length; i++)
			if (deckSelect.options[i].selected) deckSelect.remove(i);
		deckToMain();
	}

	function basicName(name) {
		if (name == "(Basic) Burn" || name == "(Basic) Money" || name == "(Basic) Turrets") return true;
		return false;
	}

	function drawMech() {
		canvas = document.querySelector("#gameMechBox canvas");
		ctx = canvas.getContext('2d');
		ctx.beginPath();
		//legs
		ctx.moveTo(20, 200);
		ctx.lineTo(20, 330);
		ctx.lineTo(150, 330);
		ctx.lineTo(110, 290);
		ctx.lineTo(110, 200);
		ctx.moveTo(80, 200);
		ctx.lineTo(80, 290);
		ctx.lineTo(120, 330);
		//body
		ctx.moveTo(10, 200);
		ctx.lineTo(120, 200);
		ctx.lineTo(120, 110);
		ctx.moveTo(120, 70);
		ctx.lineTo(120, 60);
		ctx.lineTo(10, 60);
		ctx.lineTo(10, 200);
		//arm
		ctx.moveTo(60, 130);
		ctx.lineTo(60, 150);
		ctx.lineTo(80, 150);
		ctx.lineTo(160, 70);
		ctx.lineTo(160, 50);
		ctx.lineTo(140, 50);
		ctx.lineTo(60, 130);
		ctx.moveTo(140, 50);
		ctx.lineTo(140, 70);
		ctx.lineTo(160, 70);
		//other arm
		ctx.moveTo(120, 140);
		ctx.lineTo(190, 70);
		ctx.lineTo(190, 50);
		ctx.lineTo(170, 50);
		ctx.lineTo(170, 70);
		ctx.lineTo(190, 70);
		ctx.moveTo(170, 50);
		ctx.lineTo(160, 60);
		//head and eye
		ctx.moveTo(40, 60);
		ctx.lineTo(40, 10);
		ctx.lineTo(70, 10);
		ctx.lineTo(100, 50);
		ctx.lineTo(100, 60);
		ctx.moveTo(88, 48);
		ctx.lineTo(67, 48);
		ctx.lineTo(67, 20);
		ctx.lineTo(88, 48);
		ctx.stroke();
	}

	function drawMonster() {
		canvas = document.querySelector("#gameMonsterBox canvas");
		ctx = canvas.getContext('2d');
		ctx.beginPath();
		//start at nose
		ctx.moveTo(5, 20);
		ctx.lineTo(40, 10);
		ctx.lineTo(80, 10);
		ctx.lineTo(110, 40);
		ctx.lineTo(140, 130);
		ctx.lineTo(140, 220);
		ctx.lineTo(170, 140);
		ctx.lineTo(180, 90);
		ctx.lineTo(180, 160);
		ctx.lineTo(150, 310);
		ctx.lineTo(110, 330);
		ctx.lineTo(40, 330);
		ctx.lineTo(70, 323);
		ctx.lineTo(40, 323);
		ctx.lineTo(70, 316);
		ctx.lineTo(40, 316);
		ctx.lineTo(70, 309);
		ctx.lineTo(100, 309);
		//thats where the first foot ends
		ctx.moveTo(40, 323);
		ctx.lineTo(0, 323);
		ctx.lineTo(30, 316);
		ctx.lineTo(0, 316);
		ctx.lineTo(30, 309);
		ctx.lineTo(0, 309);
		ctx.lineTo(30, 302);
		ctx.lineTo(60, 302);
		ctx.lineTo(73, 230);
		ctx.lineTo(80, 158);
		//start of left hand
		ctx.moveTo(120, 158);
		ctx.lineTo(50, 158);
		ctx.lineTo(80, 151);
		ctx.lineTo(50, 151);
		ctx.lineTo(80, 144);
		ctx.lineTo(50, 144);
		ctx.lineTo(80, 137);
		ctx.lineTo(110, 137);
		//front hand
		ctx.moveTo(50, 151);
		ctx.lineTo(10, 151);
		ctx.lineTo(40, 144);
		ctx.lineTo(10, 144);
		ctx.lineTo(40, 137);
		ctx.lineTo(10, 137);
		ctx.lineTo(40, 130);
		ctx.lineTo(70, 130);
		ctx.lineTo(80, 125);
		ctx.lineTo(80, 55);
		ctx.lineTo(70, 50);
		ctx.lineTo(30, 60);
		ctx.lineTo(20, 60);
		ctx.lineTo(50, 30);
		ctx.lineTo(5, 30);
		ctx.lineTo(5, 20);
		//back at the nose. now an eye
		ctx.moveTo(50, 15);
		ctx.lineTo(30, 23);
		ctx.lineTo(50, 23);
		ctx.lineTo(50, 15);
		ctx.stroke();
	}

	function anim(array, seq) {
		for (var j = 0; j < array.length; j++) {
			for (var k = 0; k < array[j].shots; k++) {
				var startX = array[j].startX;
				var startY = array[j].startY;
				var endX = array[j].endX;
				var endY = array[j].endY;
				var big = array[j].big;
				var tile = array[j].tile;
				var damage = array[j].damage;
				createTimeout(startX, startY, endX, endY, big, tile, damage, k, j, seq);
			}
		}
	}

	function createTimeout(startX, startY, endX, endY, big, tile, damage, k, j, seq) {
		setTimeout(function() { createInterval(startX, startY, endX, endY, big, tile, damage); }, seq ? (k + j) * 320 : k * 320);
	}

	function createInterval(startX, startY, endX, endY, big, tile, damage) {
		projectiles += 1;
		var progress = 0;
		var icon = big ? projectileTemplate.cloneNode(false) : smallProjectileTemplate.cloneNode(false);
		icon.style.display = "block";
		if (!damage) icon.style["background-color"] = "red";
		icon.style.top = startY + "px";
		icon.style.left = startX + "px";
		gameScreen.appendChild(icon);
		var mint = setInterval(function() {
			progress += 0.025;
			if (progress > 1) {
				gameScreen.removeChild(icon);
				projectiles -= 1;
				if (projectiles == 0) {
					setMode("casting");
				}
				if (damage) {
					addMonsterHP(-damage);
				} else {
					tile.addHP(-1);
				}
				castableAll();
				if (projectiles == 0 && gameMode == "casting") {
					checkQueues();
				}
				clearInterval(mint);
			} else {
				icon.style.top = (progress * endY + (1 - progress) * startY) + "px";
				icon.style.left = (progress * endX + (1 - progress) * startX) + "px";
			}
		}, 20);
	}

	function checkQueues() {
		if (qLose) {
			gameOver();
		} else if (qWin) {
			youWin();
		} else if (qVolley) {
			qVolley = false;
			volley();
		} else if (qPlant) {
			qPlant = false;
			plantExplosion();
		} else if (qAttack) {
			qAttack = false;
			attack();
		} else if (tileShotQueue.length > 0) {
			tilesShoot();
		} else if (qBetween) {
			qBetween = false;
			betweenTurn();
		}
	}

	function laserAnim(damage) {
		laserBar.style.display = "block";
		var progress = 1;
		var mint = setInterval(function() {
			progress += 1;
			if (progress > 10) {
				laserBar.style.display = "none";
				laserBar.style.top = "109px";
				laserBar.style.height = "2px";
				setMode("casting");
				addMonsterHP(-damage);
				checkQueues();
				clearInterval(mint);
			} else {
				laserBar.style.top = (110 - progress) + "px";
				laserBar.style.height = (2 * progress) + "px";				
			}
		}, 30);
	}

</script>
</body>
</html>